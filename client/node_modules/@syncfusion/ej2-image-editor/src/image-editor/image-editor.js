var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { NotifyPropertyChanges, Property, addClass, removeClass, extend } from '@syncfusion/ej2-base';
import { Event, EventHandler, getComponent, getInstance, isNullOrUndefined, L10n, getUniqueID } from '@syncfusion/ej2-base';
import { SignatureBase } from '@syncfusion/ej2-inputs';
import { Toolbar } from '@syncfusion/ej2-navigations';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';
import { ColorPicker, Uploader } from '@syncfusion/ej2-inputs';
import { createSpinner, showSpinner, hideSpinner } from '@syncfusion/ej2-popups';
import { compile, compile as templateCompiler, Browser } from '@syncfusion/ej2-base';
/**
 * Image Editor is a graphical user interface that helps to edit an image by performing actions like selection,
 * cropping, rotating, inserting text and shapes (rectangles, ellipses, lines), and drawing free hand on top of an image.
 *
 ```html
 * <div id='imageeditor'></div>
 * ```
 * ```typescript
 * <script>
 * var imageObj = new ImageEditor({});
 * imageObj.appendTo("#imageeditor");
 * </script>
 * ```
 */
var ImageEditor = /** @class */ (function (_super) {
    __extends(ImageEditor, _super);
    /**
     *
     * Constructor for creating the widget
     *
     * @param  {ImageEditorModel} options - Specifies the image editor model
     * @param  {string|HTMLDivElement} element - Specifies the target element
     */
    function ImageEditor(options, element) {
        var _this = _super.call(this, options, element) || this;
        _this.degree = 0; // current rotated state
        _this.isUndoRedo = false;
        _this.dragCanvas = false;
        _this.dragElement = '';
        _this.keyHistory = ''; // text history
        _this.flipState = ''; // current flip state whether horizontal or vertical or none
        _this.mouseDownPoint = { x: 0, y: 0 };
        _this.previousPoint = { x: 0, y: 0 }; // updates prev x and y points in mouseMove
        _this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 }; // updates drag start and end points in mousedown and mousemove
        _this.diffPoint = { x: 0, y: 0 }; // updates resize points
        _this.oldPoint = {};
        _this.objColl = []; // shapes, text obj collection
        _this.undoRedoColl = [];
        _this.imgDataColl = []; // collection of Image Data mainly used for reset state
        _this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        _this.textSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, bold: false, italic: false, underline: false };
        _this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        _this.tempTextSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, bold: false, italic: false, underline: false };
        _this.toolbarHeight = 46;
        _this.pannStart = {};
        _this.pannEnd = {};
        _this.togglePan = false;
        _this.lastX = 0;
        _this.lastY = 0;
        _this.dragStart = { x: 0, y: 0 };
        _this.dragged = false;
        _this.factor = 1; // current zoomed state
        _this.currFlipState = '';
        _this.touchEndPoint = {};
        _this.flipMethod = false;
        _this.flipDirection = '';
        _this.prevX = 0;
        _this.currX = 0;
        _this.prevY = 0;
        _this.currY = 0;
        _this.togglePen = false;
        _this.rotateMethod = false;
        _this.isBoldbtn = false;
        _this.isItalicbtn = false;
        _this.lastAction = '';
        _this.currentToolbar = 'main';
        _this.textStartPoints = { x: 0, y: 0 };
        _this.fontSizeColl = [];
        _this.tempKeyHistory = '';
        _this.penDrawColl = [];
        _this.allowDrag = false;
        _this.textRow = 1;
        _this.activeObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [] };
        _this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false,
            isInitialLine: false, isCustomCrop: false, isZoomed: false };
        _this.defToolbarItems = [];
        _this.baseImgSrc = '';
        _this.isTimer = false;
        _this.isScreenOriented = false;
        return _this;
    }
    ImageEditor_1 = ImageEditor;
    ImageEditor.prototype.preRender = function () {
        // pre render code snippets
        this.element.id = this.element.id || getUniqueID('ej2-image-editor');
        if (Browser.isDevice) {
            this.element.classList.add('e-device');
        }
        this.themeColl = {
            Bootstrap5: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Bootstrap5Dark: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Tailwind: { primaryColor: '#4f46e5', secondaryColor: '#fff' },
            TailwindDark: { primaryColor: '#22d3ee', secondaryColor: '#fff' },
            Fluent: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            FluentDark: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            Bootstrap4: { primaryColor: '#007bff', secondaryColor: '#fff' },
            Bootstrap: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            BootstrapDark: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            Material: { primaryColor: '#e3165b', secondaryColor: '#fff' },
            MaterialDark: { primaryColor: '#00b0ff', secondaryColor: '#fff' },
            Fabric: { primaryColor: '#0078d6', secondaryColor: '#fff' },
            FabricDark: { primaryColor: '#0074cc', secondaryColor: '#fff' },
            Highcontrast: { primaryColor: '#000000', secondaryColor: '#fff' }
        };
        this.defaultLocale = {
            Crop: 'Crop',
            ZoomIn: 'Zoom In',
            ZoomOut: 'Zoom Out',
            Transform: 'Transform',
            Annotation: 'Annotation',
            Text: 'Add Text',
            Pen: 'Pen',
            Reset: 'Reset',
            Save: 'Save',
            Select: 'Select',
            RotateLeft: 'Rotate Left',
            RotateRight: 'Rotate Right',
            HorizontalFlip: 'Horizontal Flip',
            VerticalFlip: 'Vertical Flip',
            OK: 'OK',
            Cancel: 'Cancel',
            FillColor: 'Fill Color',
            StrokeColor: 'Stroke Color',
            StrokeWidth: 'Stroke Width',
            FontFamily: 'Font Family',
            FontStyle: 'Font Style',
            FontSize: 'Font Size',
            FontColor: 'Font Color',
            Pan: 'Pan',
            Move: 'Move',
            Load: 'Load',
            Custom: 'Custom',
            Square: 'Square',
            Circle: 'Circle',
            Ellipse: 'Ellipse',
            Rectangle: 'Rectangle',
            Line: 'Line',
            Default: 'Default',
            Bold: 'Bold',
            Italic: 'Italic',
            BoldItalic: 'Bold Italic',
            XSmall: 'X-Small',
            Small: 'Small',
            Medium: 'Medium',
            Large: 'Large',
            XLarge: 'X-Large',
            ABC: 'ABC'
        };
        this.l10n = new L10n('image-editor', this.defaultLocale, this.locale);
    };
    /**
     *
     * To Initialize the component rendering
     *
     * @private
     * @returns {void}
     */
    ImageEditor.prototype.render = function () {
        this.initialize();
    };
    /**
     * To get component name.
     *
     * @returns {string} - Module Name
     * @private
     */
    ImageEditor.prototype.getModuleName = function () {
        return 'image-editor';
    };
    /**
     *
     * To get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     * @private
     */
    ImageEditor.prototype.getPersistData = function () {
        return this.addOnPersist([]);
    };
    /**
     *
     * Called internally if any of the property value changed.
     *
     * @param  {ImageEditorModel} newProperties - Specifies new properties
     * @param  {ImageEditorModel} oldProperties - Specifies old properties
     * @returns {void}
     * @private
     */
    ImageEditor.prototype.onPropertyChanged = function (newProperties, oldProperties) {
        for (var _i = 0, _a = Object.keys(newProperties); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'cssClass':
                    if (oldProperties.cssClass) {
                        removeClass([this.element], oldProperties.cssClass.split(' '));
                    }
                    if (newProperties.cssClass) {
                        addClass([this.element], newProperties.cssClass.split(' '));
                    }
                    break;
                case 'disabled':
                    if (newProperties.disabled) {
                        this.element.classList.add('e-disabled');
                        this.unwireEvent();
                    }
                    else {
                        this.element.classList.remove('e-disabled');
                        this.wireEvent();
                    }
                    break;
                case 'height':
                    this.element.style.height = newProperties.height;
                    break;
                case 'width':
                    this.element.style.width = newProperties.width;
                    break;
                case 'theme':
                    if (newProperties.theme) {
                        this.updateTheme();
                        this.upperContext.strokeStyle = this.themeColl[this.theme]['primaryColor'];
                        this.upperContext.fillStyle = this.themeColl[this.theme]['secondaryColor'];
                    }
                    break;
            }
        }
    };
    ImageEditor.prototype.destroy = function () {
        var classList = [];
        this.element.removeAttribute('tabindex');
        if (this.cssClass) {
            classList = classList.concat(this.cssClass.split(' '));
        }
        removeClass([this.element], classList);
        if (!this.element.getAttribute('class')) {
            this.element.removeAttribute('class');
        }
        this.unwireEvent();
        _super.prototype.destroy.call(this);
        this.element.innerHTML = '';
        this.trigger('destroyed');
    };
    ImageEditor.prototype.initialize = function () {
        this.createToolbar();
        this.createCanvas();
        this.wireEvent();
        this.updateContext(this.lowerContext);
        this.updateContext(this.upperContext);
        this.pannStart = { startX: 0, startY: 0, width: 0, height: 0 };
        this.pannEnd = { startX: 0, startY: 0, width: 0, height: 0 };
        if (this.cssClass) {
            addClass([this.element], this.cssClass.split(' '));
        }
        if (this.element) {
            createSpinner({
                target: this.element
            });
        }
    };
    /**
     *
     * This Method will add events to component (element, event, method, current reference)
     *
     * @returns {void}.
     */
    ImageEditor.prototype.wireEvent = function () {
        EventHandler.add(document, 'keydown', this.keyDownEventHandler, this);
        EventHandler.add(document, 'keypress', this.keyUpEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousedown', this.mouseDownEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(document, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler, this);
        EventHandler.add(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler, this);
        EventHandler.add(document, 'mouseup', this.canvasMouseUpHandler, this);
        EventHandler.add(this.upperCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.lowerCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.upperCanvas, 'dblclick', this.findTextPoint, this);
        EventHandler.add(this.textBox, 'mousedown', this.findTextPoint, this);
        window.addEventListener('resize', this.windowResizeHandler.bind(this));
        if ((!Browser.isIos && Browser.info.name !== 'safari')) {
            screen.orientation.addEventListener('change', this.screenOrientation.bind(this));
        }
    };
    /**
     *
     * This Method will remove events from component
     *
     * @returns {void}.
     */
    ImageEditor.prototype.unwireEvent = function () {
        EventHandler.remove(document, 'keydown', this.keyDownEventHandler);
        EventHandler.remove(document, 'keypress', this.keyUpEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousedown', this.mouseDownEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler);
        EventHandler.remove(this.upperCanvas, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(document, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler);
        EventHandler.remove(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler);
        EventHandler.remove(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler);
        EventHandler.remove(document, 'mouseup', this.canvasMouseUpHandler);
    };
    ImageEditor.prototype.updateTheme = function () {
        if (this.theme !== '') {
            this.theme = this.toPascalCase(this.theme);
        }
    };
    ImageEditor.prototype.toPascalCase = function (str) {
        var strArr = str.toLowerCase().split('-');
        for (var i = 0; i < strArr.length; i++) {
            strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].slice(1);
        }
        return strArr.join('');
    };
    ImageEditor.prototype.createCanvas = function () {
        var height = this.toolbarHeight;
        this.element.style.width = this.width;
        this.element.style.height = this.height;
        var canvasWrapper = this.element.appendChild(this.createElement('div', { id: this.element.id + '_canvasWrapper',
            className: 'e-canvas-wrapper', attrs: { style: 'height:' + (this.element.offsetHeight - height) + 'px; width:' +
                    (this.element.offsetWidth)
                    + 'px; position: relative; overflow: hidden; margin: 0 auto;' }
        }));
        this.lowerCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_lowerCanvas', attrs: { name: 'canvasImage' }
        }));
        this.upperCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_upperCanvas', attrs: { name: 'canvasImage' }
        }));
        this.inMemoryCanvas = this.createElement('canvas', {
            id: this.element.id + '_inMemoryCanvas', attrs: { name: 'canvasImage' }
        });
        this.textBox = canvasWrapper.appendChild(this.createElement('textarea', {
            id: this.element.id + '_textBox', attrs: { name: 'textBox' }
        }));
        this.textBox.setAttribute('spellcheck', 'false');
        this.upperCanvas.width = this.lowerCanvas.width = this.inMemoryCanvas.width = this.element.offsetWidth;
        this.upperCanvas.height = this.lowerCanvas.height = this.inMemoryCanvas.height = (this.element.offsetHeight - this.toolbarHeight);
        this.upperCanvas.style.position = this.lowerCanvas.style.position = this.textBox.style.position = 'absolute';
        this.textBox.style.backgroundColor = 'transparent';
        this.textBox.style.display = 'none';
        this.textBox.style.resize = 'none';
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.baseImg = this.createElement('img', {
            id: this.element.id + '_orgImg', attrs: { name: 'Image', crossorigin: 'anonymous' }
        });
        this.upperCanvas.style.cursor = 'default';
        this.upperCanvas.style.display = 'none';
        this.upperContext = this.upperCanvas.getContext('2d');
        this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
    };
    ImageEditor.prototype.createToolbar = function () {
        var _this = this;
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.length > 0)) {
            this.element.appendChild(this.createElement('div', {
                id: this.element.id + '_toolbarArea', className: 'e-toolbar-area'
            }));
            if (this.toolbarTemplate) {
                this.toolbarTemplateFn();
            }
            else {
                var toolbarItems = { cssClass: 'e-image-upload', align: 'Left', type: 'Input', template: new Uploader({}) };
                if (isNullOrUndefined(this.defToolbarItems)) {
                    this.defToolbarItems = [];
                }
                this.defToolbarItems.push(toolbarItems);
                var toolbarArea = document.getElementById(this.element.id + '_toolbarArea');
                var toolbar_1 = this.createElement('div', {
                    id: this.element.id + '_toolbar'
                });
                toolbarArea.appendChild(toolbar_1);
                var uploadItems = [
                    {
                        cssClass: 'e-image-upload',
                        align: 'Left', type: 'Input',
                        template: new Uploader({
                            selected: function () {
                                if (Browser.isDevice) {
                                    if (_this.defToolbarItems.length > 0 &&
                                        (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                                        getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar').destroy();
                                    }
                                    if (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar'))) {
                                        getComponent(document.getElementById(_this.element.id + '_bottomToolbar'), 'toolbar').destroy();
                                    }
                                    _this.initToolbarItem(false, Browser.isDevice);
                                    _this.createBottomToolbar();
                                }
                                else {
                                    if (_this.defToolbarItems.length > 0 &&
                                        (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                                        getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar').destroy();
                                    }
                                    _this.initToolbarItem(false, false);
                                }
                            }
                        })
                    }
                ];
                new Toolbar({ items: uploadItems, width: '100%',
                    created: function () {
                        _this.trigger('toolbarCreated', { toolbarType: 'main' });
                    },
                    clicked: this.defToolbarClicked.bind(this) }, '#' + this.element.id + '_toolbar');
                this.createLeftToolbarControls();
            }
            if (!isNullOrUndefined(document.getElementById(this.element.id + '_toolbar'))) {
                this.toolbarHeight = document.getElementById(this.element.id + '_toolbar').clientHeight;
            }
        }
        else {
            this.toolbarHeight = 0;
        }
    };
    ImageEditor.prototype.createBottomToolbar = function () {
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.length > 0)) {
            this.element.appendChild(this.createElement('div', {
                id: this.element.id + '_bottomToolbarArea', className: 'e-bottom-toolbar'
            }));
            if (!this.toolbarTemplate) {
                document.getElementById(this.element.id + '_canvasWrapper').style.height = (this.element.offsetHeight
                    - this.toolbarHeight * 2) - 3 + 'px';
                var toolbarArea = document.getElementById(this.element.id + '_bottomToolbarArea');
                var toolbarElem = this.createElement('div', {
                    id: this.element.id + '_bottomToolbar'
                });
                toolbarArea.appendChild(toolbarElem);
            }
            this.initBottomToolbar();
        }
    };
    ImageEditor.prototype.initBottomToolbar = function () {
        var _this = this;
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.length > 0)) {
            if (this.toolbarTemplate) {
                this.toolbarTemplateFn();
            }
            else {
                var items = this.getMainToolbarItem();
                new Toolbar({ items: items, width: '100%',
                    created: function () {
                        _this.renderAnnotationBtn();
                        _this.renderCropBtn();
                        _this.renderTransformBtn();
                        _this.trigger('toolbarCreated', { toolbarType: 'main' });
                    },
                    clicked: this.defToolbarClicked.bind(this)
                }, '#' + this.element.id + '_bottomToolbar');
                if (this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(this.element.id + '_bottomToolbar')))) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    var toolbar_2 = getComponent(this.element.id + '_bottomToolbar', 'toolbar');
                    toolbar_2.refreshOverflow();
                }
            }
        }
    };
    ImageEditor.prototype.toolbarTemplateFn = function () {
        var template;
        var templateID = this.element.id + '_toolbar';
        var toolbarArea = this.element.querySelector('#' + this.element.id + '_toolbarArea');
        if (this.toolbarTemplate) {
            this.toolbarFn = this.templateParser(this.toolbarTemplate);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (this.isAngular) {
                var templateColl = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID);
                template = (templateColl[0].nodeType === 3) ? templateColl[1] : templateColl[0];
            }
            else {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
            }
            toolbarArea.appendChild(template);
            this.renderReactTemplates();
        }
    };
    ImageEditor.prototype.templateParser = function (template) {
        if (template) {
            try {
                if (document.querySelectorAll(template).length) {
                    return templateCompiler(document.querySelector(template).innerHTML.trim());
                }
                else {
                    return compile(template);
                }
            }
            catch (error) {
                return templateCompiler(template);
            }
        }
        return undefined;
    };
    ImageEditor.prototype.getLeftToolbarItem = function (isOkBtn) {
        var toolbarItems = [];
        if (!isOkBtn) {
            toolbarItems.push({ cssClass: 'e-image-upload', align: 'Left', type: 'Input', template: new Uploader({}) });
            toolbarItems.push({ visible: false, cssClass: 'e-image-position e-btn e-flat', tooltipText: 'Position', align: 'Left' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('ZoomOut') > -1)) {
            toolbarItems.push({ id: this.element.id + '_zoomOut', prefixIcon: 'e-icons e-zoom-out', cssClass: 'top-icon e-dec-zoom',
                tooltipText: this.l10n.getConstant('ZoomOut'), align: 'Left' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('ZoomIn') > -1)) {
            toolbarItems.push({ id: this.element.id + '_zoomIn', prefixIcon: 'e-icons e-zoom-in', cssClass: 'top-icon e-inc-zoom',
                tooltipText: this.l10n.getConstant('ZoomIn'), align: 'Left' });
        }
        var tempToolbarItems = this.processToolbar('left');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    };
    ImageEditor.prototype.getRightToolbarItem = function (isOkBtn) {
        var toolbarItems = [];
        if (isOkBtn) {
            toolbarItems.push({ id: this.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: this.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Reset') > -1)) {
            toolbarItems.push({ id: this.element.id + '_reset', prefixIcon: 'e-icons e-btn-reset', cssClass: 'top-icon e-img-reset',
                tooltipText: this.l10n.getConstant('Reset'), align: 'Right' });
        }
        if (!isOkBtn) {
            if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Save') > -1)) {
                toolbarItems.push({ id: this.element.id + '_save', prefixIcon: 'e-icons e-btn-save', cssClass: 'top-icon e-save',
                    tooltipText: this.l10n.getConstant('Save'), align: 'Right', template: '<button id="' + this.element.id + '_saveBtn"></button>' });
            }
        }
        var tempToolbarItems = this.processToolbar('right');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    };
    ImageEditor.prototype.getMainToolbarItem = function (isApplyOption) {
        var toolbarItems = [];
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Crop') > -1)) {
            toolbarItems.push({ id: this.element.id + '_crop', tooltipText: this.l10n.getConstant('Crop'), align: 'Center',
                template: '<button id="' + this.element.id + '_cropBtn"></button>'
            });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Annotate') > -1)) {
            toolbarItems.push({ id: this.element.id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + this.element.id + '_annotationBtn"></button>' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Transform') > -1)) {
            toolbarItems.push({ id: this.element.id + '_transform', tooltipText: this.l10n.getConstant('Transform'), align: 'Center',
                template: '<button id="' + this.element.id + '_transformBtn"></button>'
            });
        }
        var tempToolbarItems = this.processToolbar('center');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (isApplyOption) {
            toolbarItems.push({ id: this.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: this.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ImageEditor.prototype.getZoomToolbarItem = function () {
        var toolbarItems = [];
        if (this.factor > 1) {
            toolbarItems = [
                { id: this.element.id + '_pan', prefixIcon: 'e-icons e-pan', cssClass: 'top-icon e-img-pan',
                    tooltipText: this.l10n.getConstant('Pan'), align: 'Left' }
            ];
        }
        return toolbarItems;
    };
    ImageEditor.prototype.processToolbar = function (position) {
        var toolbarItems = [];
        if (this.toolbar) {
            for (var i = 0, len = this.toolbar.length; i < len; i++) {
                if (typeof (this.toolbar[i]) === 'object') {
                    if (isNullOrUndefined(this.toolbar[i].align)) {
                        if (position === 'left') {
                            toolbarItems.push(this.toolbar[i]);
                        }
                    }
                    else if (this.toolbar[i].align.toLowerCase() === position) {
                        toolbarItems.push(this.toolbar[i]);
                    }
                }
            }
        }
        return toolbarItems;
    };
    ImageEditor.prototype.processSubToolbar = function (items) {
        var toolbarItems = [];
        if (items) {
            for (var i = 0, len = items.length; i < len; i++) {
                if (typeof (items[i]) === 'object') {
                    items[i].align = 'Center';
                    toolbarItems.push(items[i]);
                }
            }
        }
        return toolbarItems;
    };
    ImageEditor.prototype.isToolbar = function () {
        return (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.length > 0)
            || !isNullOrUndefined(this.toolbarTemplate));
    };
    ImageEditor.prototype.initToolbarItem = function (isApplyOption, isDevice, isOkBtn) {
        var _this = this;
        if (this.isToolbar()) {
            var leftItem = this.getLeftToolbarItem(isOkBtn);
            var rightItem = this.getRightToolbarItem(isOkBtn);
            var mainItem = this.getMainToolbarItem(isApplyOption);
            var zoomItem = this.getZoomToolbarItem();
            if (isDevice) {
                this.defToolbarItems = leftItem.concat(zoomItem, rightItem);
            }
            else {
                this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
            }
            new Toolbar({
                width: '100%',
                items: this.defToolbarItems,
                clicked: this.defToolbarClicked.bind(this),
                created: function () {
                    if (!isDevice) {
                        _this.renderAnnotationBtn();
                        _this.renderCropBtn();
                        _this.renderTransformBtn();
                    }
                    _this.renderSaveBtn();
                    _this.trigger('toolbarCreated', { toolbarType: 'main' });
                }
            }, '#' + this.element.id + '_toolbar');
            this.createLeftToolbarControls();
            var zoomIn = document.querySelector('#' + this.element.id + '_zoomIn');
            if (!isNullOrUndefined(zoomIn) && this.factor >= 8) {
                zoomIn.classList.add('e-disabled');
            }
            else if (!isNullOrUndefined(zoomIn)) {
                zoomIn.classList.remove('e-disabled');
            }
            var zoomOut = document.querySelector('#' + this.element.id + '_zoomOut');
            if (!isNullOrUndefined(zoomOut) && this.factor === 1) {
                zoomOut.classList.add('e-disabled');
            }
            else if (!isNullOrUndefined(zoomOut)) {
                zoomOut.classList.remove('e-disabled');
            }
            var pan = document.querySelector('#' + this.element.id + '_pan');
            if (!isNullOrUndefined(pan) && this.factor === 1) {
                pan.style.display = 'none';
            }
            else if (!isNullOrUndefined(pan)) {
                pan.style.display = 'block';
            }
            if (this.isToolbar() && (!isNullOrUndefined(document.getElementById(this.element.id + '_toolbar')))) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var toolbar_3 = getComponent(this.element.id + '_toolbar', 'toolbar');
                toolbar_3.refreshOverflow();
            }
        }
    };
    ImageEditor.prototype.createLeftToolbarControls = function () {
        if (this.defToolbarItems !== undefined && this.defToolbarItems.length > 0 &&
            (!isNullOrUndefined(document.getElementById(this.element.id + '_toolbar')))) {
            var uploadDiv = document.getElementById(this.element.id + '_toolbar')
                .querySelector('.e-image-upload');
            if (uploadDiv) {
                var uploadElem = uploadDiv.getElementsByTagName('input')[0];
                var uploadBtnElem = uploadDiv.getElementsByTagName('button')[0];
                uploadBtnElem.className = 'e-tbar-btn e-tbtn-txt e-btn top-icon';
                uploadBtnElem.innerHTML = '';
                uploadBtnElem.appendChild(this.createElement('span', {
                    className: 'e-btn-icon e-icons e-upload-icon e-icon-left'
                }));
                uploadElem.onchange = this.fileSelect.bind(this, uploadElem);
            }
        }
    };
    ImageEditor.prototype.renderAnnotationBtn = function () {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        var items = [];
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Pen') > -1)) {
            items.push({ text: this.l10n.getConstant('Pen'), id: 'pen', iconCss: 'e-icons e-free-pen' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Line') > -1)) {
            items.push({ text: this.l10n.getConstant('Line'), id: 'line', iconCss: 'e-icons e-line' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Rectangle') > -1)) {
            items.push({ text: this.l10n.getConstant('Rectangle'), id: 'rectangle', iconCss: 'e-icons e-rectangle' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Ellipse') > -1)) {
            items.push({ text: this.l10n.getConstant('Ellipse'), id: 'ellipse', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('Text') > -1)) {
            items.push({ text: this.l10n.getConstant('Text'), id: 'text', iconCss: 'e-icons e-add-text' });
        }
        var drpDownBtn = new DropDownButton({ items: items, iconCss: 'e-icons e-annotation',
            cssClass: 'e-image-popup',
            open: function (args) {
                if (_this.togglePan) {
                    _this.cancelPan();
                }
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
            },
            select: function (args) {
                var isCropSelection = false;
                var splitWords;
                if (_this.activeObj.shape !== undefined) {
                    splitWords = _this.activeObj.shape.split('-');
                }
                if (splitWords === undefined && _this.currObjType.isCustomCrop) {
                    isCropSelection = true;
                }
                else if (splitWords !== undefined && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
                _this.currObjType.isCustomCrop = false;
                if (isCropSelection || _this.togglePan) {
                    _this.refreshActiveObj();
                    _this.upperContext.clearRect(0, 0, _this.upperCanvas.width, _this.upperCanvas.height);
                    _this.refreshToolbar('main');
                }
                switch (args.item.id) {
                    case 'pen':
                        proxy.currentToolbar = 'pen';
                        _this.freeHandDraw(true);
                        break;
                    case 'text':
                        proxy.currentToolbar = 'text';
                        _this.drawShapeText();
                        break;
                    default:
                        proxy.currentToolbar = 'shapes';
                        proxy.drawShape((args.item.id).toLowerCase());
                        break;
                }
                _this.updateToolbarItems(_this.calcRatio());
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + this.element.id + '_annotationBtn');
    };
    ImageEditor.prototype.renderCropBtn = function () {
        var _this = this;
        var items = [];
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('CustomSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Custom'), id: 'custom', iconCss: 'e-icons e-custom' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('CircleSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Circle'), id: 'ellipse', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('SquareSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Square'), id: 'square', iconCss: 'e-icons e-square' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('RatioSelection') > -1)) {
            items.push({ text: '3:2', id: '3:2', iconCss: 'e-icons e-custom-a' });
            items.push({ text: '4:3', id: '4:3', iconCss: 'e-icons e-custom-b' });
            items.push({ text: '5:4', id: '5:4', iconCss: 'e-icons e-custom-c' });
            items.push({ text: '7:5', id: '7:5', iconCss: 'e-icons e-custom-d' });
            items.push({ text: '16:9', id: '16:9', iconCss: 'e-icons e-custom-e' });
        }
        var drpDownBtn = new DropDownButton({
            open: function (args) {
                if (_this.togglePan) {
                    _this.cancelPan();
                }
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
            },
            items: items, select: this.cropSelect.bind(this),
            iconCss: 'e-icons e-select', cssClass: 'e-image-popup'
        });
        drpDownBtn.appendTo('#' + this.element.id + '_cropBtn');
    };
    ImageEditor.prototype.renderTransformBtn = function () {
        var _this = this;
        var items = [];
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('RotateLeft') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateLeft'), id: 'rotateleft', iconCss: 'e-icons e-anti-clock-wise' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('RotateRight') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateRight'), id: 'rotateright', iconCss: 'e-icons e-clock-wise' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('FlipHorizontal') > -1)) {
            items.push({ text: this.l10n.getConstant('HorizontalFlip'), id: 'horizontalflip', iconCss: 'e-icons e-horizontal-flip' });
        }
        if (isNullOrUndefined(this.toolbar) || (!isNullOrUndefined(this.toolbar) && this.toolbar.indexOf('FlipVertical') > -1)) {
            items.push({ text: this.l10n.getConstant('VerticalFlip'), id: 'verticalflip', iconCss: 'e-icons e-vertical-flip' });
        }
        var drpDownBtn = new DropDownButton({
            open: function (args) {
                if (_this.togglePan) {
                    _this.cancelPan();
                }
                if (Browser.isDevice) {
                    var ht = args.element.parentElement.offsetHeight;
                    args.element.parentElement.style.display = 'none';
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        ht + 'px';
                    args.element.parentElement.style.display = 'block';
                }
            },
            items: items, select: this.transformSelect.bind(this),
            iconCss: 'e-icons e-transform', cssClass: 'e-image-popup'
        });
        drpDownBtn.appendTo('#' + this.element.id + '_transformBtn');
    };
    ImageEditor.prototype.renderSaveBtn = function () {
        var _this = this;
        var imageEditorObj = getInstance(document.getElementById(this.element.id), ImageEditor_1);
        var saveItems = [
            { text: 'JPEG', id: 'jpeg' },
            { text: 'PNG', id: 'png' },
            { text: 'SVG', id: 'svg' }
        ];
        var ddbElem = document.getElementById(this.element.id + '_saveBtn');
        if (ddbElem) {
            // Initialize the DropDownButton component.
            var saveDrpDownBtn = new DropDownButton({ items: saveItems, cssClass: 'e-caret-hide e-image-popup', iconCss: 'e-icons e-save',
                select: function (args) {
                    if (_this.togglePan) {
                        _this.cancelPan();
                    }
                    imageEditorObj.export(args.item.text);
                }
            });
            saveDrpDownBtn.appendTo('#' + this.element.id + '_saveBtn');
        }
    };
    ImageEditor.prototype.cropSelect = function (args) {
        var text = args.item.text;
        this.select(text);
        this.refreshToolbar('main', true, true);
    };
    ImageEditor.prototype.transformSelect = function (args) {
        var text = args.item.id;
        switch (text) {
            case 'rotateleft':
                this.rotate(-90);
                break;
            case 'rotateright':
                this.rotate(90);
                break;
            case 'horizontalflip':
                this.flip('Horizontal');
                break;
            case 'verticalflip':
                this.flip('Vertical');
                break;
        }
    };
    ImageEditor.prototype.getShapesToolbarItem = function (items) {
        var toolbarItems = [];
        if (items.indexOf('fillColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: this.element.id + '_fillcolor',
                cssClass: 'top-icon e-fill', tooltipText: this.l10n.getConstant('FillColor'), align: 'Center', type: 'Input',
                template: '<button id="' + this.element.id + '_fillColorBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: this.element.id + '_strokecolor',
                cssClass: 'top-icon e-stroke', tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + this.element.id + '_borderColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ id: this.element.id + '_strokeWidth', cssClass: 'top-icon e-size', tooltipText: 'Stroke Width', align: 'Center',
                type: 'Input', template: '<button id="' + this.element.id + '_borderWidthBtn"></button>' });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: this.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: this.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ImageEditor.prototype.initShapesToolbarItem = function (items) {
        var _this = this;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getShapesToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.createShapeColor(items);
                _this.createShapeBtn(items);
                if (!Browser.isDevice) {
                    _this.renderSaveBtn();
                }
                _this.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + this.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + this.element.id + '_toolbar');
        }
    };
    ImageEditor.prototype.createShapeColor = function (items) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        if (items.indexOf('fillColor') > -1) {
            this.element.querySelector('.e-template.e-fill').appendChild(this.createElement('input', {
                id: this.element.id + '_shape_fill'
            }));
            var fillColor = new ColorPicker({
                modeSwitcher: false, noColor: true, value: '',
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-fill-color',
                change: function (args) {
                    proxy.activeObj.strokeSettings.fillColor = args.currentValue.hex;
                    proxy.strokeSettings.fillColor = proxy.activeObj.strokeSettings.fillColor;
                    proxy.redrawShape(_this.activeObj);
                    if (args.currentValue.rgba === '') {
                        fillDDB_1.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        fillDDB_1.element.children[0].classList.remove('e-nocolor-item');
                        fillDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    fillDDB_1.toggle();
                }
            }, '#' + this.element.id + '_shape_fill');
            var fillDDB_1 = new DropDownButton({
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fillDDB_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = _this.element.offsetLeft + 'px';
                    }
                },
                target: '.e-shape-fill-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + this.element.id + '_fillColorBtn');
            fillColor.inline = true;
            this.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview').classList.add('e-nocolor-item');
        }
        if (items.indexOf('strokeColor') > -1) {
            this.element.querySelector('.e-template.e-stroke').appendChild(this.createElement('input', {
                id: this.element.id + '_shape_stroke'
            }));
            var strokeColor = new ColorPicker({
                modeSwitcher: false, noColor: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-stroke-color',
                change: function (args) {
                    proxy.activeObj.strokeSettings.strokeColor = args.currentValue.hex;
                    proxy.strokeSettings.strokeColor = proxy.activeObj.strokeSettings.strokeColor;
                    if (!proxy.togglePen) {
                        proxy.redrawShape(_this.activeObj);
                    }
                    strokeDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_1.toggle();
                }
            }, '#' + this.element.id + '_shape_stroke');
            var strokeDDB_1 = new DropDownButton({
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = _this.element.offsetLeft + 'px';
                    }
                },
                target: '.e-shape-stroke-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + this.element.id + '_borderColorBtn');
            strokeColor.inline = true;
            this.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview').style.background = '#fff';
        }
    };
    ImageEditor.prototype.createShapeBtn = function (items) {
        var _this = this;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('XSmall') },
            { id: '2', text: this.l10n.getConstant('Small') },
            { id: '3', text: this.l10n.getConstant('Medium') },
            { id: '4', text: this.l10n.getConstant('Large') },
            { id: '5', text: this.l10n.getConstant('XLarge') }
        ];
        var ratio = this.calcRatio();
        if (items.indexOf('strokeWidth') > -1) {
            var strokeWidthBtn = document.getElementById(this.element.id + '_borderWidthBtn');
            var spanElem_1 = document.createElement('span');
            spanElem_1.innerHTML = this.l10n.getConstant('Small');
            spanElem_1.className = 'e-shape-stroke-width';
            strokeWidthBtn.appendChild(spanElem_1);
            // Initialize the DropDownButton component.
            var drpDownBtn_1 = new DropDownButton({ items: strokeWidthItems,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = spanElem_1.innerHTML;
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    spanElem_1.textContent = args.item.text;
                    _this.activeObj.strokeSettings.strokeWidth = parseInt(args.item.id, 10);
                    if (_this.lowerCanvas.width > _this.lowerCanvas.height) {
                        _this.activeObj.strokeSettings.strokeWidth *= ((ratio.width + ratio.height) / _this.factor);
                    }
                    else {
                        _this.activeObj.strokeSettings.strokeWidth *= ((ratio.height + ratio.width) / _this.factor);
                    }
                    _this.strokeSettings.strokeWidth = _this.activeObj.strokeSettings.strokeWidth;
                    _this.redrawShape(_this.activeObj);
                    if (Browser.isDevice) {
                        if (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar'))) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_4 = getComponent(_this.element.id + '_bottomToolbar', 'toolbar');
                            toolbar_4.refreshOverflow();
                        }
                    }
                    else {
                        if (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar'))) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_5 = getComponent(_this.element.id + '_toolbar', 'toolbar');
                            toolbar_5.refreshOverflow();
                        }
                    }
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_1.appendTo('#' + this.element.id + '_borderWidthBtn');
        }
    };
    ImageEditor.prototype.getTextToolbarItem = function (items) {
        var toolbarItems = [];
        if (items.indexOf('fontFamily') > -1) {
            toolbarItems.push({ id: this.element.id + '_fontFamily', cssClass: 'top-icon e-img-font-family',
                tooltipText: this.l10n.getConstant('FontFamily'), align: 'Center',
                template: '<button id="' + this.element.id + '_fontFamilyBtn"></button>' });
        }
        if (items.indexOf('fontStyle') > -1) {
            toolbarItems.push({ id: this.element.id + '_fontStyle', cssClass: 'top-icon e-img-font-style',
                tooltipText: this.l10n.getConstant('FontStyle'), align: 'Center',
                template: '<button id="' + this.element.id + '_fontStyleBtn"></button>' });
        }
        if (items.indexOf('fontSize') > -1) {
            toolbarItems.push({ id: this.element.id + '_fontSize', cssClass: 'top-icon e-img-font-size',
                tooltipText: this.l10n.getConstant('FontSize'), align: 'Center',
                template: '<button id="' + this.element.id + '_fontSizeBtn"></button>' });
        }
        if (items.indexOf('fontColor') > -1) {
            toolbarItems.push({ cssClass: 'top-icon e-text-font-color', id: this.element.id + '_text_strokecolor',
                tooltipText: this.l10n.getConstant('FontColor'), align: 'Center',
                type: 'Input', template: '<button id="' + this.element.id + '_fontColorBtn"></button>' });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: this.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: this.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ImageEditor.prototype.getFontFamilyItems = function () {
        if (Browser.isDevice) {
            return [{ id: 'arial', text: 'ABC' }, { id: 'calibri', text: 'ABC' }, { id: 'georgia', text: 'ABC' },
                { id: 'roboto', text: 'ABC' }, { id: 'tahoma', text: 'ABC' }];
        }
        return [{ id: 'arial', text: 'Arial' }, { id: 'calibri', text: 'Calibri' }, { id: 'georgia', text: 'Georgia' },
            { id: 'roboto', text: 'Roboto' }, { id: 'tahoma', text: 'Tahoma' }];
    };
    ImageEditor.prototype.getFontSizeItems = function () {
        if (Browser.isDevice) {
            return [{ id: 'default', text: this.l10n.getConstant('ABC') }, { id: 'bold', text: this.l10n.getConstant('ABC') },
                { id: 'italic', text: this.l10n.getConstant('ABC') }, { id: 'bolditalic', text: this.l10n.getConstant('ABC') }];
        }
        return [{ id: 'default', text: this.l10n.getConstant('Default') }, { id: 'bold', text: this.l10n.getConstant('Bold') },
            { id: 'italic', text: this.l10n.getConstant('Italic') }, { id: 'bolditalic', text: this.l10n.getConstant('BoldItalic') }];
    };
    ImageEditor.prototype.initTextToolbarItem = function (items) {
        var _this = this;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getTextToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.createTextColor(items);
                _this.createTextBtn(items);
                if (!Browser.isDevice) {
                    _this.renderSaveBtn();
                }
                _this.trigger('toolbarCreated', { toolbarType: 'text' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + this.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + this.element.id + '_toolbar');
        }
    };
    ImageEditor.prototype.createTextColor = function (items) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        if (items.indexOf('fontColor') > -1) {
            this.element.querySelector('.e-template.e-text-font-color').appendChild(this.createElement('input', {
                id: this.element.id + '_text_font'
            }));
            var fontColor = new ColorPicker({
                modeSwitcher: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-text-fontt-color',
                change: function (args) {
                    if (proxy.textBox.style.display === 'none') {
                        proxy.strokeSettings.strokeColor = proxy.activeObj.strokeSettings.strokeColor = args.currentValue.hex;
                        if (!proxy.togglePen) {
                            proxy.redrawShape(_this.activeObj);
                        }
                    }
                    else if (proxy.textBox.style.display === 'block') {
                        proxy.textBox.style.color = args.currentValue.hex;
                    }
                    else if (!proxy.togglePen) {
                        proxy.redrawShape(_this.activeObj);
                    }
                    strokeDDB_2.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_2.toggle();
                }
            }, '#' + this.element.id + '_text_font');
            var strokeDDB_2 = new DropDownButton({
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB_2.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = _this.element.offsetLeft + 'px';
                    }
                },
                target: '.e-text-fontt-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + this.element.id + '_fontColorBtn');
            fontColor.inline = true;
            this.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    };
    ImageEditor.prototype.createTextBtn = function (items) {
        var _this = this;
        var ratio = this.calcRatio();
        if (items.indexOf('fontFamily') > -1) {
            var fontNameBtn = document.getElementById(this.element.id + '_fontFamilyBtn');
            var spanElem_2 = document.createElement('span');
            if (Browser.isDevice) {
                spanElem_2.innerHTML = 'ABC';
                spanElem_2.setAttribute('style', 'font-family: arial');
            }
            else {
                spanElem_2.innerHTML = 'Arial';
            }
            spanElem_2.className = 'e-text-font-family';
            fontNameBtn.appendChild(spanElem_2);
            var fontFamilyBtn_1 = new DropDownButton({ items: this.getFontFamilyItems(),
                cssClass: 'e-font-family',
                createPopupOnClick: true,
                beforeItemRender: function (args) {
                    args.element.setAttribute('style', 'font-family:' + args.element.id);
                },
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontFamilyBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var fontFamily;
                    if (_this.textBox.style.display === 'block') {
                        fontFamily = _this.textBox.style.fontFamily;
                    }
                    else {
                        fontFamily = _this.activeObj.textSettings.fontFamily;
                    }
                    args.element.querySelector('[id *= ' + '"' + fontFamily.toLowerCase()
                        + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    spanElem_2.textContent = args.item.text;
                    if (Browser.isDevice) {
                        spanElem_2.setAttribute('style', 'font-family:' + args.item.id);
                    }
                    if (_this.textBox.style.display === 'block') {
                        var temp = _this.activeObj.textSettings.fontFamily;
                        _this.activeObj.textSettings.fontFamily = _this.toPascalCase(args.item.id);
                        _this.updateFontStyles();
                        var width = _this.upperContext.measureText(_this.activeObj.keyHistory).width +
                            _this.activeObj.textSettings.fontSize * 0.5;
                        _this.textBox.style.width = Browser.isDevice ? width + 'px' : (width * ((ratio.width + ratio.height) / 2)) + 'px';
                        _this.textBox.style.fontFamily = _this.toPascalCase(args.item.id);
                        _this.activeObj.textSettings.fontFamily = temp;
                        _this.updateFontStyles();
                    }
                    else {
                        _this.textSettings.fontFamily = _this.activeObj.textSettings.fontFamily = _this.toPascalCase(args.item.id);
                        _this.redrawText(ratio);
                        _this.redrawShape(_this.activeObj);
                    }
                }
            });
            fontFamilyBtn_1.appendTo('#' + this.element.id + '_fontFamilyBtn');
        }
        if (items.indexOf('fontStyle') > -1) {
            var fontStyleBtnElem = document.getElementById(this.element.id + '_fontStyleBtn');
            var span1Elem_1 = document.createElement('span');
            if (Browser.isDevice) {
                span1Elem_1.innerHTML = this.l10n.getConstant('ABC');
            }
            else {
                span1Elem_1.innerHTML = this.l10n.getConstant('Default');
            }
            span1Elem_1.className = 'e-text-font-style';
            fontStyleBtnElem.appendChild(span1Elem_1);
            var fontStyleBtn_1 = new DropDownButton({ items: this.getFontSizeItems(),
                cssClass: 'e-font-style',
                createPopupOnClick: true,
                beforeItemRender: function (args) {
                    if (Browser.isDevice) {
                        if (args.element.id === 'bold') {
                            args.element.setAttribute('style', 'font-weight: bold');
                        }
                        else if (args.element.id === 'italic') {
                            args.element.setAttribute('style', 'font-style: italic');
                        }
                        else if (args.element.id === 'bolditalic') {
                            args.element.setAttribute('style', 'font-style: italic;font-weight: bold');
                        }
                    }
                },
                open: function (args) {
                    var fontStyle = 'default';
                    if (_this.textBox.style.display === 'block') {
                        if (_this.textBox.style.fontWeight === 'bold') {
                            fontStyle = 'bold';
                        }
                        if (_this.textBox.style.fontStyle === 'italic') {
                            fontStyle = fontStyle.replace('default', '');
                            fontStyle += 'italic';
                        }
                    }
                    else {
                        if (_this.activeObj.textSettings.bold) {
                            fontStyle = 'bold';
                        }
                        if (_this.activeObj.textSettings.italic) {
                            fontStyle = fontStyle.replace('default', '');
                            fontStyle += 'italic';
                        }
                    }
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontStyleBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    args.element.querySelector('[id *= ' + '"' + fontStyle + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    if (Browser.isDevice) {
                        if (args.item.id === 'bold') {
                            span1Elem_1.setAttribute('style', 'font-weight: bold');
                        }
                        else if (args.item.id === 'italic') {
                            span1Elem_1.setAttribute('style', 'font-style: italic');
                        }
                        else if (args.item.id === 'bolditalic') {
                            span1Elem_1.setAttribute('style', 'font-style: italic;font-weight: bold');
                        }
                        _this.applyFontStyle(args.item.id, ratio);
                    }
                    else {
                        span1Elem_1.textContent = args.item.text;
                        _this.applyFontStyle(args.item.id, ratio);
                    }
                }
            });
            fontStyleBtn_1.appendTo('#' + this.element.id + '_fontStyleBtn');
        }
        if (items.indexOf('fontSize') > -1) {
            var fontSizeBtnElem = document.getElementById(this.element.id + '_fontSizeBtn');
            var fontSizeSpanElem_1 = document.createElement('span');
            var fontSizes = this.getFontSizes();
            fontSizeSpanElem_1.innerHTML = fontSizes[0].text;
            fontSizeSpanElem_1.className = 'e-text-font-size';
            fontSizeBtnElem.appendChild(fontSizeSpanElem_1);
            var fontSizeBtn_1 = new DropDownButton({
                cssClass: 'e-font-size',
                items: fontSizes,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontSizeBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = fontSizeSpanElem_1.innerHTML;
                    args.element.querySelector('[aria-label *= ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    fontSizeSpanElem_1.textContent = args.item.text;
                    if (_this.textBox.style.display === 'block') {
                        var temp = _this.activeObj.textSettings.fontSize;
                        _this.activeObj.textSettings.fontSize = parseInt(_this.fontSizeColl[(parseInt(args.item.text, 10) - 1)].text, 10);
                        var textStyle = '';
                        if (_this.textBox.style.fontWeight === 'bold') {
                            textStyle = 'bold ';
                        }
                        if (_this.textBox.style.fontStyle === 'italic') {
                            textStyle = 'italic ';
                        }
                        if (_this.textBox.style.fontWeight === 'bold' && _this.textBox.style.fontStyle === 'italic') {
                            textStyle = 'italic bold ';
                        }
                        _this.upperContext.font = textStyle + _this.activeObj.textSettings.fontSize + 'px' + ' ' + _this.textBox.style.fontFamily;
                        var rows = _this.textBox.value.split('\n');
                        var text = _this.getMaxText(true);
                        var width = _this.upperContext.measureText(text).width +
                            _this.activeObj.textSettings.fontSize * 0.5;
                        _this.textBox.style.width = width + 'px';
                        _this.textBox.style.height = rows.length * (_this.activeObj.textSettings.fontSize + _this.activeObj.textSettings.fontSize * 0.25) + 'px';
                        _this.activeObj.textSettings.fontSize = temp;
                        _this.upperContext.font = _this.activeObj.textSettings.fontSize + 'px' + ' ' + _this.activeObj.textSettings.fontFamily;
                        _this.textBox.style.fontSize = parseInt(_this.fontSizeColl[(parseInt(args.item.text, 10) - 1)].text, 10) + 'px';
                        if (_this.textBox.style.fontFamily === 'georgia') {
                            _this.textBox.style.width = parseFloat(_this.textBox.style.width) + parseFloat(_this.textBox.style.fontSize) + 'px';
                        }
                    }
                    else {
                        _this.textSettings.fontSize = _this.activeObj.textSettings.fontSize = parseInt(_this.fontSizeColl[(parseInt(args.item.text, 10) - 1)].text, 10);
                        _this.upperContext.font = _this.activeObj.textSettings.fontSize + 'px' + ' ' + _this.activeObj.textSettings.fontFamily;
                        var rows = _this.activeObj.keyHistory.split('\n');
                        var text = _this.getMaxText();
                        var width = _this.upperContext.measureText(text).width +
                            _this.activeObj.textSettings.fontSize * 0.5;
                        var height = rows.length * (_this.activeObj.textSettings.fontSize + _this.activeObj.textSettings.fontSize * 0.25);
                        _this.setTextSelection(width, height);
                        _this.updateActiveObject(ratio, _this.activeObj.activePoint, _this.activeObj);
                        _this.redrawShape(_this.activeObj);
                        _this.redrawText(ratio);
                    }
                }
            });
            fontSizeBtn_1.appendTo('#' + this.element.id + '_fontSizeBtn');
        }
    };
    ImageEditor.prototype.getFontSizes = function () {
        var items = [];
        this.fontSizeColl = [];
        var fontSize;
        if (this.degree === 0 || this.degree % 180 === 0) {
            fontSize = this.lowerCanvas.width / 20;
        }
        else {
            fontSize = this.lowerCanvas.height / 20;
        }
        for (var i = 1; i <= 10; i++) {
            this.fontSizeColl.push({ text: (i * (Math.round(fontSize / 2))).toString() });
            items.push({ text: (i.toString()) });
        }
        return items;
    };
    ImageEditor.prototype.getTextAreaWidth = function (item) {
        var tempBold = this.activeObj.textSettings.bold;
        var tempItalic = this.activeObj.textSettings.italic;
        switch (item) {
            case 'default':
                this.activeObj.textSettings.bold = false;
                this.activeObj.textSettings.italic = false;
                break;
            case 'bold':
                this.activeObj.textSettings.bold = true;
                this.activeObj.textSettings.italic = false;
                break;
            case 'italic':
                this.activeObj.textSettings.bold = false;
                this.activeObj.textSettings.italic = true;
                break;
            case 'bolditalic':
                this.activeObj.textSettings.bold = true;
                this.activeObj.textSettings.italic = true;
                break;
        }
        this.updateFontStyles();
        var width = this.upperContext.measureText(this.activeObj.keyHistory).width +
            this.activeObj.textSettings.fontSize * 0.5;
        this.activeObj.textSettings.bold = tempBold;
        this.activeObj.textSettings.italic = tempItalic;
        return width;
    };
    ImageEditor.prototype.applyFontStyle = function (item, ratio) {
        switch (item) {
            case 'default':
                if (this.textBox.style.display === 'block') {
                    var width = this.getTextAreaWidth(item);
                    this.textBox.style.width = Browser.isDevice ? width + 'px' : (width * ((ratio.width + ratio.height) / 2)) + 'px';
                    this.textBox.style.fontWeight = 'normal';
                    this.textBox.style.fontStyle = 'normal';
                }
                else {
                    this.textSettings.bold = this.activeObj.textSettings.bold = false;
                    this.textSettings.italic = this.activeObj.textSettings.italic = false;
                    this.redrawText(ratio);
                }
                break;
            case 'bold':
                if (this.textBox.style.display === 'block') {
                    var width = this.getTextAreaWidth(item);
                    this.textBox.style.width = Browser.isDevice ? width + 'px' : (width * ((ratio.width + ratio.height) / 2)) + 'px';
                    this.textBox.style.fontWeight = 'bold';
                    this.textBox.style.fontStyle = 'normal';
                }
                else {
                    this.textSettings.bold = this.activeObj.textSettings.bold = true;
                    this.textSettings.italic = this.activeObj.textSettings.italic = false;
                    this.redrawText(ratio);
                }
                break;
            case 'italic':
                if (this.textBox.style.display === 'block') {
                    var width = this.getTextAreaWidth(item);
                    this.textBox.style.width = Browser.isDevice ? width + 'px' : (width * ((ratio.width + ratio.height) / 2)) + 'px';
                    this.textBox.style.fontWeight = 'normal';
                    this.textBox.style.fontStyle = 'italic';
                }
                else {
                    this.textSettings.bold = this.activeObj.textSettings.bold = false;
                    this.textSettings.italic = this.activeObj.textSettings.italic = true;
                    this.redrawText(ratio);
                }
                break;
            case 'bolditalic':
                if (this.textBox.style.display === 'block') {
                    var width = this.getTextAreaWidth(item);
                    this.textBox.style.width = (width / ratio.width) + 'px';
                    this.textBox.style.fontWeight = 'bold';
                    this.textBox.style.fontStyle = 'italic';
                }
                else {
                    this.textSettings.bold = this.activeObj.textSettings.bold = true;
                    this.textSettings.italic = this.activeObj.textSettings.italic = true;
                    this.redrawText(ratio);
                }
                break;
        }
    };
    ImageEditor.prototype.initZoomToolbarItem = function () {
        var _this = this;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var zoomItem = this.getZoomToolbarItem();
        this.defToolbarItems = leftItem.concat(zoomItem, rightItem);
        new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.renderSaveBtn();
                _this.trigger('toolbarCreated', { toolbarType: 'zoom' });
            }
        }, '#' + this.element.id + '_toolbar');
        this.createLeftToolbarControls();
        if (this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(this.element.id + '_toolbar')))) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var toolbar_6 = getComponent(this.element.id + '_toolbar', 'toolbar');
            toolbar_6.refreshOverflow();
        }
    };
    ImageEditor.prototype.defToolbarClicked = function (args) {
        var ratio = this.calcRatio();
        var zoomIn;
        var type = args.item.id.replace(this.element.id + '_', '').toLowerCase();
        var imageEditorObj = getInstance(document.getElementById(this.element.id), ImageEditor_1);
        var isCropSelection = false;
        var panBtn;
        var splitWords;
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (splitWords === undefined && this.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (!this.disabled) {
            switch (type) {
                case 'zoomin':
                    if (this.togglePen) {
                        this.currObjType.isZoomed = true;
                        this.freeHandDraw(false);
                    }
                    imageEditorObj.zoom(.1);
                    if (!this.togglePan) {
                        this.callMainToolbar(false, true);
                    }
                    if (this.factor > 0.95 && this.factor < 1.05) {
                        this.dragCanvas = this.togglePan = false;
                        this.callMainToolbar(false, true);
                    }
                    if (isNullOrUndefined(this.activeObj.activePoint) || this.activeObj.activePoint.width === 0) {
                        this.refreshToolbar('main');
                    }
                    else {
                        this.refreshToolbar('main', true, true);
                    }
                    panBtn = this.element.querySelector('.e-img-pan .e-btn');
                    if (!isNullOrUndefined(panBtn) && this.togglePan) {
                        panBtn.classList.add('e-selected-btn');
                    }
                    else if (!isNullOrUndefined(panBtn)) {
                        panBtn.classList.remove('e-selected-btn');
                    }
                    break;
                case 'zoomout':
                    if (this.togglePen) {
                        this.currObjType.isZoomed = true;
                        this.freeHandDraw(false);
                    }
                    imageEditorObj.zoom(-.1);
                    if (!this.togglePan) {
                        this.callMainToolbar(false, true);
                    }
                    if (this.factor > 0.95 && this.factor < 1.05) {
                        this.dragCanvas = this.togglePan = false;
                        this.callMainToolbar(false, true);
                    }
                    if (isNullOrUndefined(this.activeObj.activePoint) || this.activeObj.activePoint.width === 0) {
                        this.refreshToolbar('main');
                    }
                    else {
                        this.refreshToolbar('main', true, true);
                    }
                    panBtn = this.element.querySelector('.e-img-pan .e-btn');
                    if (!isNullOrUndefined(panBtn) && this.togglePan) {
                        panBtn.classList.add('e-selected-btn');
                    }
                    else if (!isNullOrUndefined(panBtn)) {
                        panBtn.classList.remove('e-selected-btn');
                    }
                    break;
                case 'pan':
                    this.currObjType.isCustomCrop = false;
                    if (isCropSelection) {
                        this.currObjType.isCustomCrop = false;
                        this.refreshActiveObj();
                        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                        this.refreshToolbar('main');
                    }
                    if (this.togglePan) {
                        this.cancelPan();
                    }
                    else {
                        panBtn = this.element.querySelector('.e-img-pan .e-btn');
                        panBtn.classList.add('e-selected-btn');
                        imageEditorObj.pan(true);
                    }
                    zoomIn = document.querySelector('#' + this.element.id + '_zoomIn');
                    if (!isNullOrUndefined(zoomIn) && this.factor >= 8) {
                        zoomIn.classList.add('e-disabled');
                    }
                    else if (!isNullOrUndefined(zoomIn)) {
                        zoomIn.classList.remove('e-disabled');
                    }
                    break;
                case 'cancel':
                    if (this.textBox.style.display === 'block') {
                        this.textBox.style.display = 'none';
                        this.textBox.value = '';
                        this.textBox.style.transform = '';
                        this.activeObj.strokeSettings = this.tempStrokeSettings;
                        this.activeObj.textSettings = this.tempTextSettings;
                    }
                    this.cancelItems();
                    break;
                case 'ok':
                    if (isCropSelection) {
                        this.crop();
                    }
                    else if (this.togglePen) {
                        this.freeHandDraw(false);
                    }
                    else if (this.textBox.style.display === 'block') {
                        this.redrawActObj();
                    }
                    else {
                        this.applyActObj();
                    }
                    this.callMainToolbar(false);
                    break;
                case 'text':
                    this.currObjType.isCustomCrop = false;
                    imageEditorObj.drawShapeText();
                    this.refreshToolbar(type);
                    break;
                case 'pen':
                    this.currObjType.isCustomCrop = false;
                    this.freeHandDraw(true);
                    this.refreshToolbar(type);
                    break;
                case 'reset':
                    imageEditorObj.reset();
                    break;
                case 'load':
                    break;
                case 'save':
                    break;
                case 'select':
                    break;
                case 'bold':
                    this.currObjType.isCustomCrop = false;
                    if (!this.isBoldbtn) {
                        this.activeObj.textSettings.bold = true;
                        this.isBoldbtn = true;
                        this.redrawText(ratio);
                    }
                    else {
                        this.activeObj.textSettings.bold = false;
                        this.isBoldbtn = false;
                        this.redrawText(ratio);
                    }
                    break;
                case 'italic':
                    this.currObjType.isCustomCrop = false;
                    if (!this.isItalicbtn) {
                        this.activeObj.textSettings.italic = true;
                        if (this.activeObj.textSettings.bold) {
                            this.upperContext.font = 'italic bold ' + this.activeObj.textSettings.fontSize + 'px' +
                                ' ' + this.activeObj.textSettings.fontFamily;
                        }
                        else {
                            this.upperContext.font = 'italic ' + this.activeObj.textSettings.fontSize + 'px' + ' ' +
                                this.activeObj.textSettings.fontFamily;
                        }
                        var width = this.upperContext.measureText(this.activeObj.keyHistory).width +
                            this.activeObj.textSettings.fontSize * 0.5;
                        var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
                        this.setTextSelection(width, height);
                        this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
                        this.redrawShape(this.activeObj);
                        this.isItalicbtn = true;
                    }
                    else {
                        this.activeObj.textSettings.italic = false;
                        if (this.activeObj.textSettings.bold) {
                            this.upperContext.font = 'bold ' + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
                        }
                        else {
                            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
                        }
                        var width = this.upperContext.measureText(this.activeObj.keyHistory).width +
                            this.activeObj.textSettings.fontSize * 0.5;
                        var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
                        this.setTextSelection(width, height);
                        this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
                        this.redrawShape(this.activeObj);
                        this.isItalicbtn = false;
                    }
                    break;
            }
        }
        this.trigger('toolbarItemClicked', args);
    };
    ImageEditor.prototype.cancelPan = function () {
        this.applyActObj();
        var panBtn = this.element.querySelector('.e-img-pan .e-btn');
        panBtn.classList.remove('e-selected-btn');
        this.pan(false);
    };
    ImageEditor.prototype.callMainToolbar = function (isApplyBtn, isZooming) {
        if (this.factor === 1) {
            this.refreshToolbar('main', isApplyBtn, false, isZooming);
        }
        else {
            this.refreshToolbar('main', isApplyBtn, false, isZooming);
        }
    };
    ImageEditor.prototype.cancelItems = function () {
        var ratio = this.calcRatio();
        var isCropSelection = false;
        var splitWords;
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (splitWords === undefined && this.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (this.togglePen) {
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.togglePen = false;
            this.upperCanvas.style.cursor = 'default';
            this.penDrawColl = [];
            this.imageEditorPointsColl = [];
        }
        else if (this.activeObj.shape === 'text') {
            this.activeObj.strokeSettings = this.tempStrokeSettings;
            this.activeObj.textSettings = this.tempTextSettings;
            if (this.activeObj.keyHistory === 'Enter Text' && this.activeObj.activePoint.startX === this.textStartPoints.x
                && this.activeObj.activePoint.startY === this.textStartPoints.y) {
                this.refreshActiveObj();
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.drawShapeText();
            }
            else {
                this.redrawText(ratio);
                this.redrawShape(this.activeObj);
                if (!isCropSelection && this.activeObj.topLeftCircle !== undefined) {
                    this.applyActObj();
                }
                this.clearSelection();
            }
            this.tempTextSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, bold: false, italic: false, underline: false };
        }
        else if (this.activeObj.shape === 'rectangle' || this.activeObj.shape === 'ellipse' || this.activeObj.shape === 'line') {
            this.activeObj.strokeSettings = this.tempStrokeSettings;
            this.redrawShape(this.activeObj);
            this.applyActObj();
        }
        else {
            this.refreshActiveObj();
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        }
        this.upperCanvas.style.cursor = 'default';
        this.currObjType.isCustomCrop = false;
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        this.callMainToolbar();
    };
    ImageEditor.prototype.gradient = function (a, b) {
        return (b.y - a.y) / (b.x - a.x);
    };
    ImageEditor.prototype.applyPenDraw = function () {
        if (this.togglePen && this.factor === 1 && !this.currObjType.isZoomed) {
            this.apply();
            this.penDrawColl = [];
            this.imageEditorPointsColl = [];
        }
        else {
            var tempCanvas = this.lowerCanvas.appendChild(this.createElement('canvas', {
                id: this.element.id + '_tempCanvas', attrs: { name: 'canvasImage' }
            }));
            var tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = this.lowerCanvas.width;
            tempCanvas.height = this.lowerCanvas.height;
            tempContext.drawImage(this.inMemoryCanvas, 0, 0);
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            for (var i = 0; i < this.penDrawColl.length; i++) {
                tempContext.lineWidth = 2 * this.penDrawColl[i].strokeWidth;
                tempContext.strokeStyle = this.penDrawColl[i].strokeColor;
                var nexP = void 0;
                var preP = void 0;
                var f = 0.3;
                var t = 1;
                tempContext.beginPath();
                tempContext.moveTo(this.penDrawColl[i].points[0].x, this.penDrawColl[i].points[0].y);
                var m = 0;
                var dx1 = 0;
                var dx2 = 0;
                var dy1 = 0;
                var dy2 = 0;
                preP = this.penDrawColl[i].points[0];
                for (var j = 1; j < this.penDrawColl[i].points.length; j++) {
                    var curP = this.penDrawColl[i].points[j];
                    nexP = this.penDrawColl[i].points[j + 1];
                    if (nexP) {
                        m = this.gradient(preP, nexP);
                        dx2 = (nexP.x - curP.x) * -f;
                        dy2 = dx2 * m * t;
                    }
                    else {
                        dx2 = 0;
                        dy2 = 0;
                    }
                    tempContext.bezierCurveTo(preP.x - dx1, preP.y - dy1, curP.x + dx2, curP.y + dy2, curP.x, curP.y);
                    dx1 = dx2;
                    dy1 = dy2;
                    preP = curP;
                    if (this.penDrawColl[i].points.length > 2) {
                        this.penDrawColl[i].points.shift();
                    }
                    tempContext.stroke();
                }
            }
            this.penDrawColl = [];
            this.imageEditorPointsColl = [];
            this.togglePen = false;
            var imgData = tempContext.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            var tempObj = void 0;
            for (var index = 0; index < this.imgDataColl.length; index++) {
                if (this.imgDataColl[index].operation !== 'freehanddraw') {
                    tempObj = this.imgDataColl[index];
                    break;
                }
            }
            this.imgDataColl.splice(0, 1, { operation: 'freehanddraw', value: imgData });
            this.imgDataColl.splice(1, 1, tempObj);
            this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
            this.inMemoryCanvas.width = imgData.width;
            this.inMemoryCanvas.height = imgData.height;
            this.inMemoryContext.putImageData(imgData, 0, 0);
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
            for (var j = 0; j < this.objColl.length; j++) {
                this.apply(this.objColl[j].shape, this.objColl[j]);
                this.refreshActiveObj();
            }
            this.currObjType.isZoomed = false;
        }
    };
    ImageEditor.prototype.refreshToolbar = function (type, isApplyBtn, isCropping, isZooming) {
        var args = { toolbarType: type };
        if (document.getElementById(this.element.id + '_toolbar') && this.defToolbarItems.length > 0) {
            getComponent(document.getElementById(this.element.id + '_toolbar'), 'toolbar').destroy();
        }
        if (document.getElementById(this.element.id + '_bottomToolbar') && this.defToolbarItems.length > 0) {
            if (document.getElementById(this.element.id + '_bottomToolbar').className.indexOf('e-control') > -1) {
                getComponent(document.getElementById(this.element.id + '_bottomToolbar'), 'toolbar').destroy();
            }
        }
        switch (type) {
            case 'main':
                if (Browser.isDevice) {
                    if (isCropping) {
                        this.initToolbarItem(false, true, true);
                    }
                    else {
                        this.initToolbarItem(false, true);
                    }
                }
                else if (!Browser.isDevice || isZooming) {
                    this.initToolbarItem(isApplyBtn, Browser.isDevice);
                }
                if (Browser.isDevice) {
                    this.initBottomToolbar();
                }
                break;
            case 'shapes':
                if (Browser.isDevice) {
                    this.initToolbarItem(false, true, true);
                }
                if (this.activeObj.shape === 'line') {
                    args.toolbarItems = ['strokeColor', 'strokeWidth'];
                }
                else {
                    args.toolbarItems = ['fillColor', 'strokeColor', 'strokeWidth'];
                }
                this.trigger('toolbarUpdating', args);
                this.initShapesToolbarItem(args.toolbarItems);
                break;
            case 'text':
                if (Browser.isDevice) {
                    this.initToolbarItem(false, true, true);
                }
                args.toolbarItems = ['fontFamily', 'fontStyle', 'fontSize', 'fontColor'];
                this.trigger('toolbarUpdating', args);
                this.initTextToolbarItem(args.toolbarItems);
                break;
            case 'pen':
                if (Browser.isDevice) {
                    this.initToolbarItem(false, true, true);
                }
                args.toolbarItems = ['strokeColor', 'strokeWidth'];
                this.trigger('toolbarUpdating', args);
                this.initPenToolbarItem(args.toolbarItems);
                break;
            case 'pan':
                this.initZoomToolbarItem();
                break;
        }
    };
    ImageEditor.prototype.getPenToolbarItem = function (items) {
        var toolbarItems = [];
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: this.element.id + '_pen_strokecolor',
                cssClass: 'top-icon e-pen-stroke-color',
                tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + this.element.id + '_penColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', cssClass: 'top-icon e-size',
                tooltipText: this.l10n.getConstant('StrokeWidth'),
                align: 'Center', type: 'Input', template: '<button id="' + this.element.id + '_penStrokeWidth"></button>' });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: this.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: this.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ImageEditor.prototype.initPenToolbarItem = function (items) {
        var _this = this;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getPenToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.createPenColor(items);
                _this.createPenBtn(items);
                if (!Browser.isDevice) {
                    _this.renderSaveBtn();
                }
                _this.trigger('toolbarCreated', { toolbarType: 'pen' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + this.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + this.element.id + '_toolbar');
        }
    };
    ImageEditor.prototype.createPenColor = function (items) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        if (items.indexOf('strokeColor') > -1) {
            this.element.querySelector('.e-template.e-pen-stroke-color').appendChild(this.createElement('input', {
                id: this.element.id + '_pen_stroke'
            }));
            var penColor = new ColorPicker({
                modeSwitcher: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-pen-color',
                change: function (args) {
                    proxy.activeObj.strokeSettings.strokeColor = args.currentValue.hex;
                    if (!proxy.togglePen) {
                        proxy.redrawShape(_this.activeObj);
                    }
                    strokeDDB_3.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_3.toggle();
                }
            }, '#' + this.element.id + '_pen_stroke');
            var strokeDDB_3 = new DropDownButton({
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB_3.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = _this.element.offsetLeft + 'px';
                    }
                },
                target: '.e-pen-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + this.element.id + '_penColorBtn');
            penColor.inline = true;
            this.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    };
    ImageEditor.prototype.createPenBtn = function (items) {
        var _this = this;
        var ratio = this.calcRatio();
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('XSmall') },
            { id: '2', text: this.l10n.getConstant('Small') },
            { id: '3', text: this.l10n.getConstant('Medium') },
            { id: '4', text: this.l10n.getConstant('Large') },
            { id: '5', text: this.l10n.getConstant('XLarge') }
        ];
        if (items.indexOf('strokeWidth') > -1) {
            var strokeWidthBtn = document.getElementById(this.element.id + '_penStrokeWidth');
            var spanElem_3 = document.createElement('span');
            spanElem_3.innerHTML = this.l10n.getConstant('Small');
            spanElem_3.className = 'e-pen-stroke-width';
            strokeWidthBtn.appendChild(spanElem_3);
            var drpDownBtn_2 = new DropDownButton({ items: strokeWidthItems,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_2.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = spanElem_3.innerHTML;
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    spanElem_3.textContent = args.item.text;
                    _this.setPenStroke(args.item.id, ratio);
                    if (Browser.isDevice) {
                        if (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar'))) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_7 = getComponent(_this.element.id + '_bottomToolbar', 'toolbar');
                            toolbar_7.refreshOverflow();
                        }
                    }
                    else {
                        if (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar'))) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_8 = getComponent(_this.element.id + '_toolbar', 'toolbar');
                            toolbar_8.refreshOverflow();
                        }
                    }
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_2.appendTo('#' + this.element.id + '_penStrokeWidth');
        }
    };
    ImageEditor.prototype.setPenStroke = function (args, ratio) {
        switch (parseInt(args, 10)) {
            case 1:
                this.penStrokeWidth = (ratio.width + ratio.height) * 0.4;
                break;
            case 2:
                this.penStrokeWidth = (ratio.width + ratio.height) * 0.8;
                break;
            case 3:
                this.penStrokeWidth = (ratio.width + ratio.height) * 1.2;
                break;
            case 4:
                this.penStrokeWidth = (ratio.width + ratio.height) * 1.6;
                break;
            case 5:
                this.penStrokeWidth = (ratio.width + ratio.height) * 2;
                break;
        }
    };
    ImageEditor.prototype.updateCanvas = function () {
        this.lastX = this.baseImg.width / 2;
        this.lastY = this.baseImg.height / 2;
        var wrapperWidth;
        var canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
        if (this.isScreenOriented) {
            wrapperWidth = parseFloat(canvasWrapper.style.width);
        }
        else {
            wrapperWidth = this.element.clientWidth;
        }
        var maxDimension = this.calcMaxDimension(this.baseImg.width, this.baseImg.height);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.lowerCanvas.width = this.upperCanvas.width = this.inMemoryCanvas.width = this.baseImg.width;
        this.lowerCanvas.height = this.upperCanvas.height = this.inMemoryCanvas.height = this.baseImg.height;
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
        this.lowerCanvas.style.left = this.upperCanvas.style.left = (wrapperWidth - maxDimension.width) / 2 + 1 + 'px';
        if (canvasWrapper) {
            this.lowerCanvas.style.top = this.upperCanvas.style.top = (parseFloat(canvasWrapper.style.height) - maxDimension.height - 1) / 2 + 'px';
        }
        this.lowerContext.drawImage(this.baseImg, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.updateInMemoryCanvas('updateCanvas');
        for (var i = 0, len = this.objColl.length; i < len; i++) {
            this.apply(this.objColl[i].shape, this.objColl[i]);
        }
        if (this.isUndoRedo) {
            if (this.flipState !== '') {
                this.flip(this.flipState);
            }
        }
        if (this.disabled) {
            this.element.setAttribute('class', 'e-disabled');
        }
        this.trigger('fileOpened');
    };
    ImageEditor.prototype.imageOnLoad = function (src) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        proxy.baseImg.src = proxy.baseImgSrc = src;
        this.baseImg.onload = function () {
            _this.lowerContext.drawImage(_this.baseImg, 0, 0, _this.lowerCanvas.width, _this.lowerCanvas.height);
            if (_this.togglePen) {
                // eslint-disable-next-line @typescript-eslint/tslint/config
                _this.lowerCanvas.toBlob(function (blob) {
                    showSpinner(proxy.element);
                    proxy.baseImg.src = URL.createObjectURL(blob);
                    proxy.togglePen = false;
                }, 'image/png');
                _this.inMemoryContext.clearRect(0, 0, _this.inMemoryCanvas.width, _this.inMemoryCanvas.height);
                var imgData = _this.lowerContext.getImageData(0, 0, _this.lowerCanvas.width, _this.lowerCanvas.height);
                _this.inMemoryContext.putImageData(imgData, 0, 0);
                var temp = _this.imgDataColl[0];
                _this.imgDataColl.splice(0, 1, { operation: 'freehanddraw', value: imgData });
                _this.imgDataColl.splice(1, 1, temp);
            }
            else {
                hideSpinner(_this.element);
                _this.element.style.opacity = '1';
                _this.updateCanvas();
                _this.isUndoRedo = false;
            }
            if (Browser.isDevice) {
                if (_this.isToolbar() && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar'))) &&
                    (!isNullOrUndefined(getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar')))) {
                    getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar').destroy();
                }
                if (!isNullOrUndefined(document.getElementById(_this.element.id + '_bottomToolbar')) &&
                    (!isNullOrUndefined(getComponent(document.getElementById(_this.element.id + '_bottomToolbar'), 'toolbar')))) {
                    getComponent(document.getElementById(_this.element.id + '_bottomToolbar'), 'toolbar').destroy();
                }
                _this.initToolbarItem(false, Browser.isDevice);
                _this.createBottomToolbar();
            }
            else {
                if (_this.isToolbar() && (!isNullOrUndefined(document.getElementById(_this.element.id + '_toolbar'))) &&
                    (!isNullOrUndefined(getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar')))) {
                    getComponent(document.getElementById(_this.element.id + '_toolbar'), 'toolbar').destroy();
                }
                _this.initToolbarItem(false, false);
            }
        };
    };
    ImageEditor.prototype.refreshActiveObj = function () {
        this.activeObj = {};
        this.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        this.activeObj.flipObjColl = [];
        this.activeObj.strokeSettings = this.strokeSettings;
        this.activeObj.textSettings = this.textSettings;
    };
    ImageEditor.prototype.redrawText = function (ratio) {
        if (this.activeObj.textSettings.bold) {
            this.upperContext.font = 'bold ' + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
        }
        if (this.activeObj.textSettings.italic) {
            this.upperContext.font = 'bold ' + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
        }
        if (this.activeObj.textSettings.bold && this.activeObj.textSettings.italic) {
            this.upperContext.font = 'italic bold ' + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
        }
        if (!this.activeObj.textSettings.bold && !this.activeObj.textSettings.italic) {
            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
        }
        var rows = this.activeObj.keyHistory.split('\n');
        var text = this.textBox.style.display === 'block' ? this.getMaxText(true) : this.getMaxText();
        var width = this.upperContext.measureText(text).width + this.activeObj.textSettings.fontSize * 0.5;
        var height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25);
        this.setTextSelection(width, height);
        this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
        this.redrawShape(this.activeObj);
    };
    ImageEditor.prototype.setTextSelection = function (width, height) {
        var degree = this.degree;
        if (this.activeObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - this.activeObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        for (var i = 0; i < this.activeObj.flipObjColl.length; i++) {
            if (degree === 0) {
                if (this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.endX - width,
                        startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.endX),
                        endY: this.activeObj.activePoint.startY + (height ? height : 0) };
                }
                else if (this.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                    this.activeObj.activePoint.startY = this.activeObj.activePoint.endY - height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.startX + (width ? width : 0)),
                        endY: this.activeObj.activePoint.endY };
                }
                else {
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.startX + (width ? width : 0)),
                        endY: this.activeObj.activePoint.startY + (height ? height : 0) };
                }
            }
            else if (degree === 90) {
                if (this.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX - height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                        startY: this.activeObj.activePoint.endY - width,
                        endX: (this.activeObj.activePoint.endX),
                        endY: this.activeObj.activePoint.endY };
                }
                else if (this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.endX),
                        endY: this.activeObj.activePoint.startY + (width ? width : 0) };
                }
                else {
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX - height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.endX),
                        endY: this.activeObj.activePoint.startY + (width ? width : 0) };
                }
            }
            else if (degree === 180) {
                if (this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    this.activeObj.activePoint.startY = this.activeObj.activePoint.endY - height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                        startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.startX + width),
                        endY: this.activeObj.activePoint.endY };
                }
                else if (this.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + height;
                    this.activeObj.activePoint = { endX: this.activeObj.activePoint.endX, endY: this.activeObj.activePoint.endY,
                        startX: (this.activeObj.activePoint.endX - (width ? width : 0)),
                        startY: this.activeObj.activePoint.startY };
                }
                else {
                    this.activeObj.activePoint = { endX: this.activeObj.activePoint.endX, endY: this.activeObj.activePoint.endY,
                        startX: (this.activeObj.activePoint.endX - (width ? width : 0)),
                        startY: this.activeObj.activePoint.endY - (height ? height : 0) };
                }
            }
            else if (degree === 270) {
                if (this.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                        startY: this.activeObj.activePoint.startY,
                        endX: (this.activeObj.activePoint.startX + height),
                        endY: this.activeObj.activePoint.startY + (width ? width : 0) };
                }
                else if (this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX - height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                        startY: this.activeObj.activePoint.endY - (width ? width : 0),
                        endX: this.activeObj.activePoint.endX,
                        endY: this.activeObj.activePoint.endY };
                }
                else {
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + height;
                    this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                        startY: this.activeObj.activePoint.endY - (width ? width : 0),
                        endX: this.activeObj.activePoint.endX,
                        endY: this.activeObj.activePoint.endY };
                }
            }
        }
        if (this.activeObj.flipObjColl.length === 0) {
            if (degree === 0) {
                this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                    endX: (this.activeObj.activePoint.startX + (width ? width : 0)),
                    endY: this.activeObj.activePoint.startY + (height ? height : 0) };
            }
            else if (degree === 90) {
                this.activeObj.activePoint.startX = this.activeObj.activePoint.endX - height;
                this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY,
                    endX: (this.activeObj.activePoint.endX),
                    endY: this.activeObj.activePoint.startY + (width ? width : 0) };
            }
            else if (degree === 180) {
                this.activeObj.activePoint = { endX: this.activeObj.activePoint.endX, endY: this.activeObj.activePoint.endY,
                    startX: (this.activeObj.activePoint.endX - (width ? width : 0)),
                    startY: this.activeObj.activePoint.endY - (height ? height : 0) };
            }
            else if (degree === 270) {
                this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + height;
                this.activeObj.activePoint = { startX: this.activeObj.activePoint.startX,
                    startY: this.activeObj.activePoint.endY - (width ? width : 0),
                    endX: this.activeObj.activePoint.endX,
                    endY: this.activeObj.activePoint.endY };
            }
        }
        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        if (this.degree === 360 || this.degree === -360) {
            this.degree = 0;
        }
    };
    ImageEditor.prototype.updateUndoRedoColl = function (operation, value, previousObj, currentObj) {
        this.undoRedoColl.push({ operation: operation, value: value, previousObj: previousObj, currentObj: currentObj });
    };
    ImageEditor.prototype.fileSelect = function (inputElement, args) {
        showSpinner(this.element);
        this.element.style.opacity = '0.5';
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var filesData = args.target.files[0];
        if (this.imgDataColl.length > 0) {
            this.imgDataColl = [];
            this.reset();
        }
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var URL = window.URL;
        var url = URL.createObjectURL(filesData);
        this.imageOnLoad(url.toString());
        inputElement.value = '';
    };
    ImageEditor.prototype.findTextPoint = function (e) {
        if (this.activeObj.shape === 'text') {
            this.textBox.style.transformOrigin = '0 0';
            var degree = void 0;
            var scale = '';
            if (this.activeObj.shapeDegree === 0) {
                degree = this.degree;
            }
            else {
                degree = this.degree - this.activeObj.shapeDegree;
            }
            if (degree < 0) {
                degree = 360 + degree;
            }
            if (this.activeObj.flipObjColl.length > 0) {
                // need to add scale value according to length.
                for (var i = 0; i < this.activeObj.flipObjColl.length; i++) {
                    if (degree !== 0 && degree % 90 === 0 && degree !== 180) {
                        scale += this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(1, -1)' :
                            'scale(-1, 1)';
                    }
                    else {
                        scale += this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(-1, 1)' :
                            'scale(1, -1)';
                    }
                    if (this.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                        this.textBox.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                    else if (this.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                        this.textBox.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                }
            }
            else {
                this.textBox.style.transform = 'rotate(' + degree + 'deg)';
            }
            this.findTextTarget(e);
        }
    };
    ImageEditor.prototype.getStrokeWidth = function (text) {
        var strokeWidth;
        switch (text) {
            case '1':
                strokeWidth = this.l10n.getConstant('XSmall');
                break;
            case '2':
                strokeWidth = this.l10n.getConstant('Small');
                break;
            case '3':
                strokeWidth = this.l10n.getConstant('Medium');
                break;
            case '4':
                strokeWidth = this.l10n.getConstant('Large');
                break;
            case '5':
                strokeWidth = this.l10n.getConstant('XLarge');
                break;
        }
        return strokeWidth;
    };
    ImageEditor.prototype.updateToolbarItems = function (ratio) {
        var selFillElem = this.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview');
        var selStrokeElem = this.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview');
        var selTextStrokeElem = this.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview');
        var selPenStrokeElem = this.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview');
        var strokeWidthElem = this.element.querySelector('.e-shape-stroke-width');
        var fontFamilyElem = this.element.querySelector('.e-text-font-family');
        var fontSizeElem = this.element.querySelector('.e-text-font-size');
        var fontStyleElem = this.element.querySelector('.e-text-font-style');
        if (selFillElem) {
            if (this.activeObj.strokeSettings.fillColor === '') {
                selFillElem.classList.add('e-nocolor-item');
            }
            else {
                selFillElem.classList.remove('e-nocolor-item');
                selFillElem.style.background = this.activeObj.strokeSettings.fillColor;
            }
            getComponent(this.element.id + '_shape_fill', 'colorpicker').value
                = this.activeObj.strokeSettings.fillColor + 'ff';
        }
        if (selStrokeElem) {
            selStrokeElem.style.background = this.activeObj.strokeSettings.strokeColor;
            getComponent(this.element.id + '_shape_stroke', 'colorpicker').value
                = this.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (selTextStrokeElem) {
            selTextStrokeElem.style.background = this.activeObj.strokeSettings.strokeColor;
            getComponent(this.element.id + '_text_font', 'colorpicker').value
                = this.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (selPenStrokeElem) {
            selPenStrokeElem.style.background = this.activeObj.strokeSettings.strokeColor;
            getComponent(this.element.id + '_pen_stroke', 'colorpicker').value
                = this.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (fontFamilyElem) {
            if (Browser.isDevice) {
                fontFamilyElem.setAttribute('style', 'font-family:' + this.activeObj.textSettings.fontFamily.toLowerCase());
            }
            else {
                fontFamilyElem.textContent = this.activeObj.textSettings.fontFamily;
            }
        }
        if (fontSizeElem) {
            for (var i = 0; i < this.fontSizeColl.length; i++) {
                if (parseInt(this.fontSizeColl[i].text, 10) >= this.activeObj.textSettings.fontSize) {
                    fontSizeElem.textContent = (i + 1).toString();
                    break;
                }
            }
        }
        if (fontStyleElem) {
            if (Browser.isDevice) {
                if (!this.activeObj.textSettings.bold && !this.activeObj.textSettings.italic) {
                    fontStyleElem.setAttribute('style', '');
                }
                else if (this.activeObj.textSettings.bold && this.activeObj.textSettings.italic) {
                    fontStyleElem.setAttribute('style', 'font-style: italic;font-weight: bold');
                }
                else if (this.activeObj.textSettings.bold) {
                    fontStyleElem.setAttribute('style', 'font-weight: bold');
                }
                else {
                    fontStyleElem.setAttribute('style', 'font-style: italic');
                }
            }
            else {
                if (!this.activeObj.textSettings.bold && !this.activeObj.textSettings.italic) {
                    fontStyleElem.textContent = 'Default';
                }
                else if (this.activeObj.textSettings.bold && this.activeObj.textSettings.italic) {
                    fontStyleElem.textContent = 'Bold Italic';
                }
                else if (this.activeObj.textSettings.bold) {
                    fontStyleElem.textContent = 'Bold';
                }
                else {
                    fontStyleElem.textContent = 'Italic';
                }
            }
        }
        if (strokeWidthElem) {
            var strokeWidth = Math.round((this.activeObj.strokeSettings.strokeWidth /
                (ratio.width + ratio.height))).toString();
            strokeWidthElem.textContent = this.getStrokeWidth(strokeWidth);
        }
    };
    ImageEditor.prototype.setTimer = function (e) {
        if (!this.isTimer && this.timer > 10) {
            this.findTextPoint(e);
            if (Browser.isDevice) {
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            }
        }
    };
    ImageEditor.prototype.touchStartHandler = function (e) {
        e.preventDefault();
        this.timer = setTimeout(this.setTimer.bind(this), 1000, e);
        this.mouseDownEventHandler(e);
        EventHandler.add(this.lowerCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(this.lowerCanvas, 'touchmove', this.mouseMoveEventHandler, this); // Unbind mousedown to prevent double triggers from touch devices
        EventHandler.add(this.upperCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(this.upperCanvas, 'touchmove', this.mouseMoveEventHandler, this); // Unbind mousedown to prevent double triggers from touch devices
    };
    ImageEditor.prototype.mouseDownEventHandler = function (e) {
        if (e.type === 'touchstart' && e.currentTarget === this.lowerCanvas && this.imgDataColl.length === 0) {
            return;
        }
        var ratio = this.calcRatio();
        if (this.dragCanvas) {
            this.canvasMouseDownHandler(e);
        }
        else {
            e.preventDefault();
            var x = void 0;
            var y = void 0;
            if (e.type === 'mousedown') {
                x = e.clientX;
                y = e.clientY;
            }
            else {
                this.touchEndPoint.x = x = e.touches[0].clientX;
                this.touchEndPoint.y = y = e.touches[0].clientY;
            }
            this.redrawActObj(x, y);
            if (this.upperCanvas.style.cursor === 'crosshair' || (Browser.isDevice && this.togglePen)) {
                if (this.togglePen) {
                    this.canvasRatio = this.calcRatio();
                    if (isNullOrUndefined(this.activeObj.strokeSettings)) {
                        this.activeObj.strokeSettings = this.strokeSettings;
                    }
                    if (isNullOrUndefined(this.penStrokeWidth)) {
                        this.penStrokeWidth = (ratio.width + ratio.height) * 0.8;
                    }
                    if (this.activeObj.strokeSettings.strokeWidth === (ratio.width + ratio.height) * 0.4 &&
                        this.strokeSettings.strokeWidth === (ratio.width + ratio.height) * 0.4) {
                        this.activeObj.strokeSettings.strokeWidth = this.strokeSettings.strokeWidth =
                            2 * ((ratio.width + ratio.height) / this.factor);
                    }
                    this.minStrokeWidth = this.maxStrokeWidth = this.penStrokeWidth;
                    this.velocity = 0.7;
                    this.upperContext.strokeStyle = this.activeObj.strokeSettings.strokeColor;
                    this.upperContext.fillStyle = this.activeObj.strokeSettings.strokeColor;
                    this.mouseDownHandler(e, this.upperCanvas, this.pannStart, this.factor); // To call signature base
                }
                else {
                    this.refreshActiveObj();
                    this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                }
                this.currObjType.isActiveObj = false;
                this.dragElement = '';
                this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
            }
            if ((this.upperCanvas.style.cursor !== 'crosshair' && e.type.toLowerCase() === 'touchstart') ||
                (this.currObjType.isActiveObj && this.upperCanvas.style.cursor !== 'default' && !this.togglePen)) {
                this.findTarget(x, y, e.type);
            }
            else if ((this.currObjType.shape === '' || this.currObjType.isCustomCrop) && !this.togglePen && this.upperCanvas.style.cursor !== 'default') {
                this.setActivePoint(x, y);
            }
            if (!isNullOrUndefined(this.activeObj)) {
                var isCropSelection = false;
                var splitWords = void 0;
                if (this.activeObj.shape !== undefined) {
                    splitWords = this.activeObj.shape.split('-');
                }
                if (splitWords === undefined && (this.currObjType.isCustomCrop || this.togglePen)) {
                    isCropSelection = true;
                }
                else if (splitWords !== undefined && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
                if ((this.activeObj.shape === 'rectangle') || (this.activeObj.shape === 'ellipse')
                    || (this.activeObj.shape === 'line')) {
                    this.refreshToolbar('shapes');
                }
                else if (this.activeObj.shape === 'text') {
                    this.refreshToolbar('text');
                }
                else if (!isCropSelection) {
                    this.callMainToolbar();
                }
                this.updateToolbarItems(ratio);
            }
        }
    };
    ImageEditor.prototype.mouseMoveEventHandler = function (e) {
        e.preventDefault();
        if (this.textBox.style.display === 'none') {
            this.isTimer = true;
        }
        var x;
        var y;
        if (e.type === 'mousemove') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        this.canvasMouseMoveHandler(e);
        if (this.currObjType.isActiveObj && (this.activeObj.activePoint !== undefined || this.objColl.length > 0) &&
            !this.dragCanvas || this.activeObj.activePoint !== undefined) {
            if (this.dragElement === '') {
                this.setCursor(x, y);
                this.findTarget(x, y, e.type);
            }
        }
        if (this.currObjType.isDragging) {
            this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            var initialDraw = this.updateActivePoint(x, y);
            this.drawObject('duplicate', null, initialDraw);
        }
    };
    ImageEditor.prototype.mouseUpEventHandler = function (e) {
        e.preventDefault();
        var x;
        var y;
        if (e.type === 'mouseup') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            x = this.touchEndPoint.x;
            y = this.touchEndPoint.y;
        }
        if (e.type === 'touchend') {
            if (this.textBox.style.display === 'none') {
                this.isTimer = false;
                this.timer = 0;
            }
        }
        var bbox = this.upperCanvas.getBoundingClientRect();
        var ratio = this.calcRatio();
        if (this.factor === 1) {
            x = (x - bbox.left) * ratio.width;
            y = (y - bbox.top) * ratio.height;
        }
        else {
            x = (x - bbox.left) + ((this.pannStart.startX) / ratio.width * this.factor);
            y = (y - bbox.top) + ((this.pannStart.startY) / ratio.height * this.factor);
        }
        if (e.currentTarget === this.upperCanvas) {
            this.currObjType.shape = this.currObjType.shape.toLowerCase();
            if (!this.togglePen && !this.dragCanvas) {
                this.applyCurrActObj(x, y);
            }
        }
        if (this.togglePen && e.currentTarget === this.upperCanvas) {
            this.penDrawColl.push({ strokeWidth: this.penStrokeWidth, strokeColor: this.activeObj.strokeSettings.strokeColor, points: this.imageEditorPointsColl });
            this.imageEditorPointsColl = [];
        }
        else {
            this.currObjType.shape = '';
        }
        this.dragElement = '';
        this.currObjType.isInitialLine = this.currObjType.isDragging = false;
        this.oldPoint.x = undefined;
        this.oldPoint.y = undefined;
    };
    ImageEditor.prototype.keyDownEventHandler = function (e) {
        var _this = this;
        var shapeChangingArgs = {};
        var beforeSave = { fileName: 'ImageEditor', fileType: 'Png', cancel: false };
        switch (e.key) {
            case (e.ctrlKey && 's'):
                this.trigger('beforeSave', beforeSave, function (observableSaveArgs) {
                    if (!beforeSave.cancel) {
                        _this.export(observableSaveArgs.fileType, observableSaveArgs.fileName);
                    }
                });
                e.preventDefault();
                e.stopImmediatePropagation();
                break;
            case 'Delete':
                shapeChangingArgs = { action: 'delete', previousShapeSettings: this.activeObj, currentShapeSettings: null };
                this.keyHistory = '';
                this.clearSelection();
                this.trigger('shapeChanging', shapeChangingArgs);
                this.refreshToolbar('main');
                break;
            case 'Escape':
                if (this.togglePan) {
                    this.refreshToolbar(this.currentToolbar);
                    this.pan(false);
                }
                else {
                    this.cancelItems();
                }
                break;
            case 'Enter':
                this.crop();
                break;
            default:
                if (Browser.isDevice && this.textBox.style.display === 'block') {
                    setTimeout(this.textKeyDown.bind(this), 1, e);
                }
                break;
        }
    };
    ImageEditor.prototype.keyUpEventHandler = function (e) {
        setTimeout(this.textKeyDown.bind(this), 1, e);
    };
    ImageEditor.prototype.canvasMouseDownHandler = function (e) {
        e.preventDefault();
        var ratio = this.calcRatio();
        if (e.type === 'mousedown') {
            this.lastX = e.offsetX || (e.pageX - this.lowerCanvas.offsetLeft);
            this.lastY = e.offsetY || (e.pageY - this.lowerCanvas.offsetTop);
        }
        else {
            this.lastX = e.touches[0].clientX || (e.touches[0].pageX - this.lowerCanvas.offsetLeft);
            this.lastY = e.touches[0].clientY || (e.touches[0].pageY - this.lowerCanvas.offsetTop);
        }
        this.lastX *= ratio.width;
        this.lastY *= ratio.height;
        if (this.dragCanvas || this.factor !== 1) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.dragStart = this.lowerContext.transformedPoint(this.lastX, this.lastY);
            this.dragged = false;
        }
    };
    ImageEditor.prototype.canvasMouseMoveHandler = function (e) {
        if (this.dragCanvas && this.factor > 1) {
            this.lowerCanvas.style.cursor = 'grab';
        }
        else {
            this.dragCanvas = this.togglePan = false;
            this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'default';
        }
        var ratio = this.calcRatio();
        if (e.type === 'mousemove') {
            this.lastX = e.offsetX || (e.pageX - this.lowerCanvas.offsetLeft);
            this.lastY = e.offsetY || (e.pageY - this.lowerCanvas.offsetTop);
        }
        else {
            this.lastX = e.touches[0].clientX || (e.touches[0].pageX - this.lowerCanvas.offsetLeft);
            this.lastY = e.touches[0].clientY || (e.touches[0].pageY - this.lowerCanvas.offsetTop);
        }
        this.lastX *= ratio.width;
        this.lastY *= ratio.height;
        this.dragged = true;
        if (this.dragStart && this.dragCanvas) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var pt = this.lowerContext.transformedPoint(this.lastX, this.lastY);
            var transitionArgs = { startPoint: { x: this.dragStart.x, y: this.dragStart.y },
                endPoint: { x: pt.x, y: pt.y } };
            this.trigger('panning', transitionArgs);
            var xDiff = pt.x - this.dragStart.x;
            var yDiff = pt.y - this.dragStart.y;
            var xxDiff = xDiff;
            var yyDiff = yDiff;
            this.lowerContext.translate(xDiff, yDiff);
            this.upperContext.translate(xDiff, yDiff);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var pt1 = this.lowerContext.transformedPoint(0, 0);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var pt2 = this.lowerContext.transformedPoint(this.lowerCanvas.width, this.lowerCanvas.height);
            if (xDiff >= 0) {
                if (pt1.x < 1) {
                    xDiff = 0;
                }
            }
            else {
                if (pt2.x > this.lowerCanvas.width) {
                    xDiff = 0;
                }
            }
            if (yDiff >= 0) {
                if (pt1.y < 1) {
                    yDiff = 0;
                }
            }
            else {
                if (pt2.y > this.lowerCanvas.height) {
                    yDiff = 0;
                }
            }
            this.lowerContext.translate(-xxDiff, -yyDiff);
            this.upperContext.translate(-xxDiff, -yyDiff);
            this.lowerContext.translate(xDiff, yDiff);
            this.upperContext.translate(xDiff, yDiff);
            this.redraw();
        }
    };
    ImageEditor.prototype.canvasMouseUpHandler = function (e) {
        e.preventDefault();
        this.dragStart = null;
        this.currObjType.isDragging = false;
    };
    ImageEditor.prototype.textKeyDown = function (e) {
        if (String.fromCharCode(e.which) === '\r') {
            this.textRow += 1;
        }
        this.textBox.setAttribute('rows', this.textRow.toString());
        this.textBox.style.height = 'auto';
        this.textBox.style.height = this.textBox.scrollHeight + 'px';
        this.setTextBoxWidth(e);
        if (Browser.isDevice) {
            this.textBox.style.width = parseFloat(this.textBox.style.width) + this.textBox.style.fontSize + 'px';
        }
        var rows = this.textBox.value.split('\n');
        this.textRow = rows.length;
        this.textBox.setAttribute('rows', this.textRow.toString());
    };
    ImageEditor.prototype.adjustToScreen = function () {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        this.applyActObj();
        this.refreshActiveObj();
        if (this.imgDataColl.length > 0) {
            showSpinner(this.element);
            this.element.style.opacity = '0.5';
        }
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.lowerCanvas.width = this.upperCanvas.width = this.element.offsetWidth;
        this.lowerCanvas.height = this.upperCanvas.height = this.element.offsetHeight;
        var canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
        if (!isNullOrUndefined(canvasWrapper)) {
            canvasWrapper.style.width = this.element.offsetWidth + 'px';
            canvasWrapper.style.height = this.element.offsetHeight + 'px';
            if (Browser.isDevice) {
                canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - (2 * this.toolbarHeight)) - 3 + 'px';
            }
            else {
                canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - this.toolbarHeight) - 3 + 'px';
            }
        }
        this.redrawImg();
        // eslint-disable-next-line @typescript-eslint/tslint/config
        this.lowerCanvas.toBlob(function (blob) {
            proxy.baseImg.src = URL.createObjectURL(blob);
        }, 'image/png');
        if (this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(this.element.id + '_toolbar')))) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var toolbar_9 = getComponent(proxy.element.id + '_toolbar', 'toolbar');
            toolbar_9.refreshOverflow();
        }
    };
    ImageEditor.prototype.screenOrientation = function () {
        if (Browser.isDevice) {
            this.isScreenOriented = true;
            setTimeout(this.adjustToScreen.bind(this), 100);
        }
    };
    ImageEditor.prototype.windowResizeHandler = function () {
        if (!Browser.isDevice) {
            this.adjustToScreen();
        }
    };
    ImageEditor.prototype.redrawImg = function () {
        var wrapperWidth;
        var canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
        if (this.isScreenOriented) {
            wrapperWidth = parseFloat(canvasWrapper.style.width);
        }
        else {
            wrapperWidth = this.element.clientWidth;
        }
        var maxDimension = this.calcMaxDimension(this.inMemoryCanvas.width, this.inMemoryCanvas.height);
        this.lowerCanvas.width = this.upperCanvas.width = this.inMemoryCanvas.width;
        this.lowerCanvas.height = this.upperCanvas.height = this.inMemoryCanvas.height;
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
        this.lowerCanvas.style.left = this.upperCanvas.style.left = (wrapperWidth - maxDimension.width) / 2 + 1 + 'px';
        this.lowerCanvas.style.top = this.upperCanvas.style.top = (this.element.offsetHeight - this.toolbarHeight - maxDimension.height) / 2 + 1 + 'px';
        this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ImageEditor.prototype.updateContext = function (ctx) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var xform = new DOMMatrix();
        ctx.getTransform = function () {
            return xform;
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var savedTransforms = [];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var save = ctx.save;
        ctx.save = function () {
            savedTransforms.push(xform.translate(0, 0));
            return save.call(ctx);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var restore = ctx.restore;
        ctx.restore = function () {
            xform = savedTransforms.pop();
            return restore.call(ctx);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var scale = ctx.scale;
        ctx.scale = function (sx, sy) {
            xform = _this.scaleNonUniform(xform, sx, sy);
            proxy.factor = xform.a;
            return scale.call(ctx, sx, sy);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var rotate = ctx.rotate;
        ctx.rotate = function (radians) {
            xform = xform.rotate(radians * 180 / Math.PI);
            return rotate.call(ctx, radians);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var translate = ctx.translate;
        ctx.translate = function (dx, dy) {
            xform = xform.translate(dx, dy);
            return translate.call(ctx, dx, dy);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var transform = ctx.transform;
        ctx.transform = function (a, b, c, d, e, f) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var m2 = new DOMMatrix();
            m2.a = a;
            m2.b = b;
            m2.c = c;
            m2.d = d;
            m2.e = e;
            m2.f = f;
            xform = xform.multiply(m2);
            return transform.call(ctx, a, b, c, d, e, f);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var setTransform = ctx.setTransform;
        ctx.setTransform = function (a, b, c, d, e, f) {
            xform.a = a;
            xform.b = b;
            xform.c = c;
            xform.d = d;
            xform.e = e;
            xform.f = f;
            return setTransform.call(ctx, a, b, c, d, e, f);
        };
        var pt = new DOMPoint();
        ctx.transformedPoint = function (x, y) {
            pt.x = x;
            pt.y = y;
            return pt.matrixTransform(xform.inverse());
        };
    };
    ImageEditor.prototype.scaleNonUniform = function (xform, sx, sy) {
        xform.m11 *= sx;
        xform.m12 *= sx;
        xform.m13 *= sx;
        xform.m14 *= sx;
        xform.m21 *= sy;
        xform.m22 *= sy;
        xform.m23 *= sy;
        xform.m24 *= sy;
        return xform;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ImageEditor.prototype.zoomImg = function (clicks) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var pt = this.lowerContext.transformedPoint(this.lastX, this.lastY);
        var scaleFactor = 1.1;
        var transitionArgs = { zoomPoint: { x: pt.x, y: pt.y }, zoomLevel: clicks };
        this.trigger('zooming', transitionArgs);
        this.lowerContext.translate(pt.x, pt.y);
        this.upperContext.translate(pt.x, pt.y);
        var factor = Math.pow(scaleFactor, clicks);
        this.factor += (factor - 1);
        this.lowerContext.scale(factor, factor);
        this.upperContext.scale(factor, factor);
        this.lowerContext.translate(-pt.x, -pt.y);
        this.upperContext.translate(-pt.x, -pt.y);
        var ratio = this.calcRatio();
        if (!isNullOrUndefined(this.strokeSettings.strokeWidth)) {
            this.strokeSettings.strokeWidth = 2 * (ratio.width + ratio.height) / this.factor;
        }
        if (this.factor > 0.99 && this.factor < 1.01) {
            this.factor = 1;
            this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
            this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
            for (var j = 0; j < this.objColl.length; j++) {
                this.apply(this.objColl[j].shape, this.objColl[j]);
                this.refreshActiveObj();
            }
        }
        else {
            if (this.factor > 1) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var pt1 = this.lowerContext.transformedPoint(0, 0);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var pt2 = this.lowerContext.transformedPoint(this.lowerCanvas.width, this.lowerCanvas.height);
                var xDiff = pt.x;
                var yDiff = pt.y;
                if (pt1.x < 1) {
                    xDiff = -xDiff;
                }
                else if (pt2.x > this.lowerCanvas.width) {
                    xDiff = pt2.x - this.lowerCanvas.width;
                }
                if (pt1.y < 1) {
                    yDiff = -yDiff;
                }
                else if (pt2.y > this.lowerCanvas.height) {
                    yDiff = pt2.y - this.lowerCanvas.height;
                }
                if (xDiff !== pt.x || yDiff !== pt.y) {
                    if (xDiff === pt.x) {
                        xDiff = 0;
                    }
                    if (yDiff === pt.y) {
                        yDiff = 0;
                    }
                    this.lowerContext.translate(xDiff, yDiff);
                    this.upperContext.translate(xDiff, yDiff);
                }
            }
            this.redraw();
        }
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ImageEditor.prototype.handleScroll = function (e) {
        var delta = e.wheelDelta ? e.wheelDelta / 40 : e.detail ? -e.detail : 0;
        if (delta) {
            this.zoom(delta);
        }
        return e.preventDefault() && false;
    };
    ImageEditor.prototype.redraw = function () {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var p1 = this.lowerContext.transformedPoint(0, 0);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var p2 = this.lowerContext.transformedPoint(this.lowerCanvas.width, this.lowerCanvas.height);
        this.pannStart.startX = p1.x;
        this.pannStart.startY = p1.y;
        this.pannEnd.startX = this.lowerCanvas.width - p2.x;
        this.pannEnd.startY = this.lowerCanvas.height - p2.y;
        this.lowerContext.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
        this.upperContext.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
        this.lowerContext.save();
        this.upperContext.save();
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.lowerContext.restore();
        this.upperContext.restore();
        this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
        for (var j = 0; j < this.objColl.length; j++) {
            this.apply(this.objColl[j].shape, this.objColl[j]);
            this.refreshActiveObj();
        }
    };
    ImageEditor.prototype.applyCurrActObj = function (x, y) {
        var isInside = false;
        var ratio = this.calcRatio();
        var actObj = extend({}, this.activeObj, {}, true);
        if (this.factor !== 1) {
            actObj = this.setCursorForZoomState(actObj, ratio, true);
        }
        if (isNullOrUndefined(actObj.activePoint)) {
            return;
        }
        if ((x >= Math.floor(actObj.activePoint.startX) && x <= Math.ceil(actObj.activePoint.endX) &&
            y >= Math.floor(actObj.activePoint.startY) && y <= Math.ceil(actObj.activePoint.endY)) ||
            (actObj.shape === 'text')) {
            isInside = true;
        }
        if (!isInside) {
            if (this.activeObj.horTopLine !== undefined && this.activeObj.horTopLine.startX !== 0 && this.activeObj.horTopLine.endX !== 0
                && !this.currObjType.isCustomCrop && this.currObjType.shape !== '') {
                this.objColl.push(extend({}, this.activeObj, {}, true));
            }
            if (this.activeObj.shape === 'text' || (this.currObjType.shape === 'ellipse' || this.currObjType.shape === 'rectangle' ||
                this.currObjType.shape === 'line')) {
                for (var j = 0; j < this.objColl.length; j++) {
                    this.apply(this.objColl[j].shape, this.objColl[j]);
                }
                this.apply('shape');
            }
        }
    };
    ImageEditor.prototype.updateTextFromTextArea = function (ratio) {
        this.activeObj.keyHistory = this.textBox.value;
        this.textBox.style.display = 'none';
        this.textBox.value = '';
        this.updateFontStyles();
        var width = this.upperContext.measureText(this.activeObj.keyHistory).width +
            this.activeObj.textSettings.fontSize * 0.5;
        var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
        var rows = this.activeObj.keyHistory.split('\n');
        if (rows.length > 1) {
            height *= rows.length;
            var widthColl = [];
            for (var i = 0; i < rows.length; i++) {
                widthColl.push(this.upperContext.measureText(rows[i]).width +
                    this.activeObj.textSettings.fontSize * 0.5);
            }
            width = Math.max.apply(Math, widthColl);
        }
        this.setTextSelection(width, height);
        this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
    };
    ImageEditor.prototype.redrawActObj = function (x, y) {
        var ratio = this.calcRatio();
        var splitWords;
        var bbox = this.upperCanvas.getBoundingClientRect();
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (this.activeObj.horTopLine !== undefined && (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
            if (this.textBox.style.display === 'block') {
                this.activeObj.textSettings.fontFamily = this.textBox.style.fontFamily;
                this.activeObj.strokeSettings.strokeColor = this.textBox.style.color;
                if (this.textBox.style.fontWeight === 'bold') {
                    this.activeObj.textSettings.bold = true;
                }
                else {
                    this.activeObj.textSettings.bold = false;
                }
                if (this.textBox.style.fontStyle === 'italic') {
                    this.activeObj.textSettings.italic = true;
                }
                else {
                    this.activeObj.textSettings.italic = false;
                }
                this.activeObj.textSettings.fontSize = (parseFloat(this.textBox.style.fontSize) * ((ratio.width + ratio.height) / 2)) / this.factor;
                if (x && y) {
                    x -= bbox.left;
                    y -= bbox.top;
                    if ((x !== this.activeObj.activePoint.startX / ratio.width) && (y !== this.activeObj.activePoint.startY /
                        ratio.height)) {
                        this.updateTextFromTextArea(ratio);
                        this.applyActObj();
                    }
                }
                else {
                    this.updateTextFromTextArea(ratio);
                    this.apply(this.activeObj.shape, this.activeObj);
                    this.objColl.push(this.activeObj);
                    this.refreshActiveObj();
                    this.textBox.style.transform = '';
                    this.refreshToolbar('main');
                }
            }
            else {
                this.applyActObj();
            }
        }
    };
    ImageEditor.prototype.setTextBoxPos = function (actObj, degree, flip, x, y, ratio) {
        var point = { x: x, y: y };
        if (degree === 0) {
            if (flip.toLowerCase() === 'horizontal') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left) +
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) + actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
            else if (flip.toLowerCase() === 'vertical') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left) -
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) - actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
            else {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
        }
        else if (degree === 90) {
            if (flip.toLowerCase() === 'horizontal') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
            else if (flip.toLowerCase() === 'vertical') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
            else {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left) +
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) + actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
        }
        else if (degree === 180) {
            if (flip.toLowerCase() === 'horizontal') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
            else if (flip.toLowerCase() === 'vertical') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
            else {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left) +
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) + actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
        }
        else if (degree === 270) {
            if (flip.toLowerCase() === 'horizontal') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left) +
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) + actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
            else if (flip.toLowerCase() === 'vertical') {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left) -
                        actObj.activePoint.width / ratio.width;
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                }
                else {
                    point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left) - actObj.activePoint.width;
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top);
                }
            }
            else {
                if (this.factor === 1) {
                    point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                        actObj.activePoint.height / ratio.height;
                }
                else {
                    point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                        + parseFloat(this.lowerCanvas.style.left);
                    point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                        + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                }
            }
        }
        return point;
    };
    ImageEditor.prototype.setTextBoxPoints = function (actObj, degree, flip, x, y, ratio) {
        var point = { x: x, y: y };
        if (degree === 0) {
            if (actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                            actObj.activePoint.height / ratio.height;
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                            actObj.activePoint.height / ratio.height;
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                    }
                }
            }
            else {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left +
                            actObj.activePoint.width / ratio.width);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                            actObj.activePoint.height / ratio.height;
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left) + actObj.activePoint.width;
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
        }
        else if (degree === 90) {
            if (actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top) +
                            actObj.activePoint.height / ratio.height;
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top) + actObj.activePoint.height;
                    }
                }
            }
            else {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
        }
        else if (degree === 180) {
            if (actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left)
                            + actObj.activePoint.width / ratio.width;
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
            else {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
        }
        else if (degree === 270) {
            if (actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
            else {
                if (flip.toLowerCase() === 'horizontal') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.startX / ratio.width) + parseFloat(this.lowerCanvas.style.left) +
                            actObj.activePoint.width / ratio.width;
                        point.y = (actObj.activePoint.startY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.startX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.startY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
                else if (flip.toLowerCase() === 'vertical') {
                    if (this.factor === 1) {
                        point.x = (actObj.activePoint.endX / ratio.width) + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY / ratio.height) + parseFloat(this.lowerCanvas.style.top);
                    }
                    else {
                        point.x = (actObj.activePoint.endX - ((this.pannStart.startX) / ratio.width * this.factor))
                            + parseFloat(this.lowerCanvas.style.left);
                        point.y = (actObj.activePoint.endY - ((this.pannStart.startY) / ratio.height * this.factor))
                            + parseFloat(this.lowerCanvas.style.top);
                    }
                }
            }
        }
        return point;
    };
    ImageEditor.prototype.findTextTarget = function (e) {
        var x;
        var y;
        if (e.type === 'dblclick') {
            x = e.clientX;
            y = e.clientY;
        }
        else if (e.type === 'touchstart') {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        var bbox = this.upperCanvas.getBoundingClientRect();
        var ratio = this.calcRatio();
        var degree;
        var flip = '';
        if (this.activeObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - this.activeObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (this.activeObj.shapeFlip === this.currFlipState) {
            flip = '';
        }
        else {
            flip = this.currFlipState;
        }
        var temp;
        if (this.textBox.style.display === 'block') {
            x -= bbox.left;
            y -= bbox.top;
        }
        else {
            temp = extend({}, this.activeObj, {}, true);
            for (var i = 0; i < this.objColl.length; i++) {
                if (JSON.stringify(this.activeObj) === JSON.stringify(this.objColl[i])) {
                    this.objColl.splice(i, 1);
                }
            }
            this.lowerContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
            for (var i = 0; i < this.objColl.length; i++) {
                this.apply(this.objColl[i].shape, this.objColl[i]);
            }
            this.activeObj = temp;
            this.updateFontStyles();
            if (this.factor === 1) {
                x = (x - bbox.left) * ratio.width;
                y = (y - bbox.top) * ratio.height;
            }
            else {
                x = (x - bbox.left) + ((this.pannStart.startX) / ratio.width * this.factor);
                y = (y - bbox.top) + ((this.pannStart.startY) / ratio.height * this.factor);
            }
            var actObj = extend({}, this.activeObj, {}, true);
            if (this.factor !== 1) {
                actObj = this.setCursorForZoomState(actObj, ratio, true);
            }
            if (x >= (actObj.activePoint.startX - actObj.topLeftCircle.radius) &&
                x <= (actObj.activePoint.endX + actObj.topLeftCircle.radius) &&
                y >= (actObj.activePoint.startY - actObj.topLeftCircle.radius) &&
                y <= (actObj.activePoint.endY + actObj.topLeftCircle.radius)) {
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                if (actObj.flipObjColl.length === 4) {
                    actObj.flipObjColl = [];
                    flip = '';
                }
                if (flip === '' && actObj.flipObjColl.length > 1) {
                    flip = actObj.flipObjColl[actObj.flipObjColl.length - 1];
                }
                if (actObj.flipObjColl.length <= 1) {
                    var points = this.setTextBoxPos(actObj, degree, flip, x, y, ratio);
                    x = points.x;
                    y = points.y;
                }
                else {
                    var points = this.setTextBoxPoints(actObj, degree, flip, x, y, ratio);
                    x = points.x;
                    y = points.y;
                }
                this.textBox.style.display = 'block';
                this.textBox.style.left = x + 'px';
                this.textBox.style.top = y + 'px';
                this.textBox.style.fontFamily = actObj.textSettings.fontFamily;
                this.textBox.style.fontSize = actObj.textSettings.fontSize / ((ratio.width + ratio.height) / 2) * this.factor + 'px';
                this.textBox.style.color = actObj.strokeSettings.strokeColor;
                this.textBox.style.fontWeight = actObj.textSettings.bold ? 'bold' : 'normal';
                this.textBox.style.fontStyle = actObj.textSettings.italic ? 'italic' : 'normal';
                this.textBox.style.border = '2px solid ' + this.themeColl[this.theme]['primaryColor'];
                this.textBox.value = actObj.keyHistory;
                this.textBox.style.overflow = 'hidden';
                this.textBox.style.height = 'auto';
                if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {
                    if (this.factor === 1) {
                        this.textBox.style.width = (actObj.activePoint.height / ratio.height) + 'px';
                        this.textBox.style.height = (actObj.activePoint.width / ratio.width) + 'px';
                    }
                    else {
                        this.textBox.style.width = actObj.activePoint.height + 'px';
                        this.textBox.style.height = actObj.activePoint.width + 'px';
                    }
                }
                else {
                    if (this.factor === 1) {
                        this.textBox.style.width = (actObj.activePoint.width / ratio.width) + 'px';
                        this.textBox.style.height = (actObj.activePoint.height / ratio.height) + 'px';
                    }
                    else {
                        this.textBox.style.width = actObj.activePoint.width + 'px';
                        this.textBox.style.height = actObj.activePoint.height + 'px';
                    }
                }
                this.setTextBoxWidth();
                this.setTextBoxHeight();
            }
            else {
                this.applyActObj();
            }
        }
    };
    ImageEditor.prototype.setTextBoxHeight = function () {
        var ratio = this.calcRatio();
        var textBoxTop;
        var degree;
        var flip = '';
        var actObj = extend({}, this.activeObj, {}, true);
        if (this.factor !== 1) {
            actObj = this.setCursorForZoomState(actObj, ratio, true);
        }
        if (actObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (actObj.shapeFlip === this.currFlipState) {
            flip = '';
        }
        else {
            flip = this.currFlipState;
        }
        if (degree === 0) {
            if (flip.toLowerCase() === 'vertical') {
                this.textBox.style.maxHeight = (parseFloat(this.lowerCanvas.style.maxHeight) - (parseFloat(this.lowerCanvas.style.maxHeight)
                    - parseFloat(this.textBox.style.top))) + 'px';
            }
            else {
                textBoxTop = parseFloat(this.textBox.style.top) - parseFloat(this.lowerCanvas.style.top);
                this.textBox.style.maxHeight = (parseFloat(this.lowerCanvas.style.maxHeight) - textBoxTop) + 'px';
            }
        }
        else if (degree === 90) {
            if (flip.toLowerCase() === 'horizontal') {
                this.textBox.style.maxHeight = (parseFloat(this.lowerCanvas.style.maxWidth) - (parseFloat(this.textBox.style.left)
                    - parseFloat(this.lowerCanvas.style.left))) + 'px';
            }
            else {
                this.textBox.style.maxHeight = (parseFloat(this.textBox.style.left)
                    - parseFloat(this.lowerCanvas.style.left)) + 'px';
            }
        }
        else if (degree === 180) {
            if (flip.toLowerCase() === 'vertical') {
                textBoxTop = parseFloat(this.textBox.style.top) - parseFloat(this.lowerCanvas.style.top);
                this.textBox.style.maxHeight = (parseFloat(this.lowerCanvas.style.maxHeight) - textBoxTop) + 'px';
            }
            else {
                this.textBox.style.maxHeight = (parseFloat(this.textBox.style.top)
                    - parseFloat(this.lowerCanvas.style.top)) + 'px';
            }
        }
        else if (degree === 270) {
            if (flip.toLowerCase() === 'horizontal') {
                this.textBox.style.maxHeight = (parseFloat(this.textBox.style.left)
                    - parseFloat(this.lowerCanvas.style.left)) + 'px';
            }
            else {
                this.textBox.style.maxHeight = parseFloat(this.lowerCanvas.style.maxWidth) - (parseFloat(this.textBox.style.left)
                    - parseFloat(this.lowerCanvas.style.left)) + 'px';
            }
        }
        this.textBox.style.maxHeight = ((parseFloat(this.textBox.style.maxHeight) - parseFloat(this.textBox.style.fontSize) * 0.5)) + 'px';
    };
    ImageEditor.prototype.setTextBoxWidth = function (e) {
        var ratio = this.calcRatio();
        var text = this.getMaxText(true);
        if (this.textBox.style.display === 'block') {
            this.updateFontStyles(true);
        }
        else {
            this.updateFontStyles();
        }
        var textBoxWidth = (this.upperContext.measureText(text).width + (parseFloat(this.textBox.style.fontSize) / 2));
        var letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;
        var actObj = extend({}, this.activeObj, {}, true);
        if (this.factor !== 1) {
            actObj = this.setCursorForZoomState(actObj, ratio, true);
        }
        var degree;
        var flip = '';
        if (actObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (actObj.shapeFlip === this.currFlipState) {
            flip = '';
        }
        else {
            flip = this.currFlipState;
        }
        if ((!isNullOrUndefined(e) && parseFloat(this.textBox.style.width) < (textBoxWidth + letterWidth)) || isNullOrUndefined(e)) {
            if (degree === 0) {
                if (flip.toLowerCase() === 'horizontal') {
                    if ((parseFloat(this.textBox.style.left) - parseFloat(this.lowerCanvas.style.left)) - textBoxWidth - letterWidth > 0) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
                else {
                    if ((parseFloat(this.lowerCanvas.style.maxWidth) - (parseFloat(this.textBox.style.left)
                        - parseFloat(this.lowerCanvas.style.left))) > (textBoxWidth + letterWidth)) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
            }
            else if (degree === 90) {
                if (flip.toLowerCase() === 'vertical') {
                    if ((parseFloat(this.textBox.style.top) - parseFloat(this.lowerCanvas.style.top)) - textBoxWidth - letterWidth > 0) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
                else {
                    if ((parseFloat(this.lowerCanvas.style.maxHeight) - (parseFloat(this.textBox.style.top)
                        - parseFloat(this.lowerCanvas.style.top))) > (textBoxWidth + letterWidth)) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
            }
            else if (degree === 180) {
                if (flip.toLowerCase() === 'horizontal') {
                    if ((parseFloat(this.lowerCanvas.style.maxWidth) - (parseFloat(this.textBox.style.left)
                        - parseFloat(this.lowerCanvas.style.left))) > (textBoxWidth + letterWidth)) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
                else {
                    if ((parseFloat(this.textBox.style.left) - parseFloat(this.lowerCanvas.style.left)) - textBoxWidth - letterWidth > 0) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
            }
            else if (degree === 270) {
                if (flip.toLowerCase() === 'vertical') {
                    if ((parseFloat(this.lowerCanvas.style.maxHeight) - (parseFloat(this.textBox.style.top)
                        - parseFloat(this.lowerCanvas.style.top))) > (textBoxWidth + letterWidth)) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
                else {
                    if ((parseFloat(this.textBox.style.top) - parseFloat(this.lowerCanvas.style.top)) - textBoxWidth - letterWidth > 0) {
                        this.textBox.style.width = (textBoxWidth + letterWidth) + 'px';
                    }
                }
            }
        }
    };
    ImageEditor.prototype.setActivePoint = function (startX, startY) {
        if (isNullOrUndefined(this.activeObj.activePoint)) {
            return;
        }
        if (this.currObjType.isText) {
            var textWidth = startX ? startX : 0;
            var textHeight = startY ? startY : this.activeObj.textSettings.fontSize;
            if (this.activeObj.textSettings.fontSize === undefined) {
                this.activeObj.textSettings.fontSize = (Math.abs(this.baseImg.width - this.baseImg.height)) * 0.1;
            }
            this.setTextSelection(textWidth, textHeight);
            this.mouseDownPoint.x = this.activeObj.activePoint.endX;
            this.mouseDownPoint.y = this.activeObj.activePoint.endY;
            if (this.activeObj.horTopLine !== undefined) {
                this.activeObj.activePoint = extend({}, this.activeObj.activePoint, {}, true);
            }
            this.drawObject('duplicate');
        }
        else if (startX && startY) {
            this.activeObj.activePoint.startX = this.mouseDownPoint.x = startX;
            this.activeObj.activePoint.startY = this.mouseDownPoint.y = startY;
            this.currObjType.isDragging = true;
        }
        else {
            var selectInfo = this.activeObj;
            this.activeObj.activePoint = { startX: selectInfo.horTopLine.startX, startY: selectInfo.horTopLine.startY,
                endX: selectInfo.horTopLine.endX, endY: selectInfo.horTopLine.endY };
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.updateActivePoint = function (x, y) {
        var initialDraw = false;
        var bbox = this.lowerCanvas.getBoundingClientRect();
        var ratio = this.calcRatio();
        if (this.dragElement !== '') {
            if (this.factor === 1) {
                x = (x - bbox.left) * ratio.width;
                y = (y - bbox.top) * ratio.height;
            }
            else {
                x = ((x - bbox.left) * ratio.width) / this.factor + this.pannStart.startX;
                y = ((y - bbox.top) * ratio.height) / this.factor + this.pannStart.startY;
            }
        }
        var maxDimension = this.calcMaxDimension(this.activeObj.activePoint.width, this.activeObj.activePoint.height);
        var shapeResizingArgs = { action: 'resize', previousShapeSettings: this.activeObj };
        var shapeMovingArgs = { action: 'move', previousShapeSettings: this.activeObj };
        switch (this.dragElement.toLowerCase()) {
            case 'nw-resize':
                this.updateNWPoints(x, y, maxDimension);
                break;
            case 'n-resize':
                this.updateNPoints(x, y);
                break;
            case 'ne-resize':
                this.updateNEPoints(x, y, maxDimension);
                break;
            case 'w-resize':
                this.updateWPoints(x, y);
                break;
            case 'e-resize':
                this.updateEPoints(x, y);
                break;
            case 'sw-resize':
                this.updateSWPoints(x, y, maxDimension);
                break;
            case 's-resize':
                this.updateSPoints(x, y);
                break;
            case 'se-resize':
                this.updateSEPoints(x, y, maxDimension);
                break;
            default:
                if (this.dragPoint.startX) {
                    var width = (this.dragPoint.endX - this.previousPoint.x);
                    var height = (this.dragPoint.endY - this.previousPoint.y);
                    if (this.factor !== 1) {
                        width = (width * ratio.width) / this.factor;
                        height = (height * ratio.height) / this.factor;
                    }
                    this.activeObj.activePoint.startX += width;
                    this.activeObj.activePoint.endX += width;
                    this.activeObj.activePoint.startY += height;
                    this.activeObj.activePoint.endY += height;
                    var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                    if (this.activeObj.shape !== 'text' && !this.allowDrag) {
                        if (this.factor > 1 && (this.activeObj.activePoint.startX < this.pannStart.startX ||
                            this.activeObj.activePoint.endX > endPoint.x) && (this.activeObj.activePoint.startY < this.pannStart.startY ||
                            this.activeObj.activePoint.endY > endPoint.y)) {
                            this.activeObj.activePoint.startX -= width;
                            this.activeObj.activePoint.endX -= width;
                            this.activeObj.activePoint.startY -= height;
                            this.activeObj.activePoint.endY -= height;
                        }
                        else if (this.factor > 1 && (this.activeObj.activePoint.startX < this.pannStart.startX ||
                            this.activeObj.activePoint.endX > endPoint.x)) {
                            this.activeObj.activePoint.startX -= width;
                            this.activeObj.activePoint.endX -= width;
                        }
                        else if (this.factor > 1 && (this.activeObj.activePoint.startY < this.pannStart.startY ||
                            this.activeObj.activePoint.endY > endPoint.y)) {
                            this.activeObj.activePoint.startY -= height;
                            this.activeObj.activePoint.endY -= height;
                        }
                    }
                    if (this.activeObj.activePoint.startX >= this.pannStart.startX && this.activeObj.activePoint.startY >=
                        this.pannStart.startY && this.activeObj.activePoint.endX <= endPoint.x && this.activeObj.activePoint.endY
                        <= endPoint.y) {
                        this.allowDrag = false;
                    }
                }
                else {
                    this.activeObj.activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;
                    this.activeObj.activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;
                    if (this.factor === 1) {
                        this.activeObj.activePoint.startX = (this.activeObj.activePoint.startX - bbox.left) * ratio.width;
                        this.activeObj.activePoint.startY = (this.activeObj.activePoint.startY - bbox.top) * ratio.height;
                        initialDraw = false;
                    }
                    else {
                        this.activeObj.activePoint.startX = (this.activeObj.activePoint.startX - bbox.left) + ((this.pannStart.startX)
                            / ratio.width * this.factor);
                        this.activeObj.activePoint.startY = (this.activeObj.activePoint.startY - bbox.top) + ((this.pannStart.startY)
                            / ratio.height * this.factor);
                        initialDraw = true;
                    }
                    x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;
                    y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;
                    if (this.factor === 1) {
                        this.activeObj.activePoint.endX = (x - bbox.left) * ratio.width;
                        this.activeObj.activePoint.endY = (y - bbox.top) * ratio.height;
                        initialDraw = false;
                    }
                    else {
                        this.activeObj.activePoint.endX = (x - bbox.left) + ((this.pannStart.startX) / ratio.width * this.factor);
                        this.activeObj.activePoint.endY = (y - bbox.top) + ((this.pannStart.startY) / ratio.height * this.factor);
                        initialDraw = true;
                    }
                }
                break;
        }
        shapeResizingArgs.currentShapeSettings = this.activeObj;
        shapeMovingArgs.currentShapeSettings = this.activeObj;
        this.trigger('shapeChanging', shapeMovingArgs);
        this.trigger('shapeChanging', shapeResizingArgs);
        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        return initialDraw;
    };
    ImageEditor.prototype.updateNWPoints = function (x, y, maxDimension) {
        var diff;
        var width;
        var height;
        var scale;
        var percentage;
        var prevDiffX = this.diffPoint.x;
        var prevDiffY = this.diffPoint.y;
        if (this.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = this.activeObj.activePoint.startX - x;
                this.diffPoint.y = this.activeObj.activePoint.startY - y;
            }
            else {
                this.diffPoint.x = this.oldPoint.x - x;
                this.diffPoint.y = this.oldPoint.y - y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = diff / 10;
            this.activeObj.activePoint.startX -= (maxDimension.width / 100) * percentage;
            this.activeObj.activePoint.startY -= (maxDimension.height / 100) * percentage;
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            var degree = void 0;
            var maxText = this.getMaxText();
            if (this.activeObj.shapeDegree === 0) {
                degree = this.degree;
            }
            else {
                degree = this.degree - this.activeObj.shapeDegree;
            }
            if (degree === 0 || degree === 180) {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.width / maxText.length) * 2;
            }
            else {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.height / maxText.length) * 2;
            }
        }
        else {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.startX = x;
                this.activeObj.activePoint.startY = y;
                if (this.activeObj.activePoint.startX > this.activeObj.activePoint.endX) {
                    var temp = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = temp;
                    this.dragElement = 'ne-resize';
                }
                if (this.activeObj.activePoint.startY > this.activeObj.activePoint.endY) {
                    var temp = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = temp;
                    this.dragElement = 'sw-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.startX < x && this.activeObj.activePoint.startY < y) {
                    width = x - this.activeObj.activePoint.startX;
                    height = y - this.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX += newScale.x;
                    this.activeObj.activePoint.startY += newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.startX -= newScale.x;
                        this.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = this.activeObj.activePoint.startX - x;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX -= newScale.x;
                    this.activeObj.activePoint.startY -= newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.startX += newScale.x;
                        this.activeObj.activePoint.startY += newScale.y;
                    }
                }
            }
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.updateNPoints = function (x, y) {
        var width;
        var height;
        var scale;
        if (this.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.startY = y;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
                if (this.activeObj.activePoint.startY > this.activeObj.activePoint.endY) {
                    var temp = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = temp;
                    this.dragElement = 's-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.endX > x && this.activeObj.activePoint.startY < y) {
                    width = this.activeObj.activePoint.endX - x;
                    height = y - this.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX -= newScale.x;
                    this.activeObj.activePoint.startY += newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.endX += newScale.x;
                        this.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - this.activeObj.activePoint.endX;
                    height = this.activeObj.activePoint.startY - y;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX += newScale.x;
                    this.activeObj.activePoint.startY -= newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.endX -= newScale.x;
                        this.activeObj.activePoint.startY += newScale.y;
                    }
                }
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            }
        }
    };
    ImageEditor.prototype.updateNEPoints = function (x, y, maxDimension) {
        var diff;
        var width;
        var height;
        var scale;
        var percentage;
        var prevDiffX = this.diffPoint.x;
        var prevDiffY = this.diffPoint.y;
        if (this.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = x - this.activeObj.activePoint.endX;
                this.diffPoint.y = this.activeObj.activePoint.startY - y;
            }
            else {
                this.diffPoint.x = x - this.oldPoint.x;
                this.diffPoint.y = this.oldPoint.y - y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = diff / 10;
            this.activeObj.activePoint.endX += (maxDimension.width / 100) * percentage;
            this.activeObj.activePoint.startY -= (maxDimension.height / 100) * percentage;
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            var degree = void 0;
            var maxText = this.getMaxText();
            if (this.activeObj.shapeDegree === 0) {
                degree = this.degree;
            }
            else {
                degree = this.degree - this.activeObj.shapeDegree;
            }
            if (degree === 0 || degree === 180) {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.width / maxText.length) * 2;
            }
            else {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.height / maxText.length) * 2;
            }
        }
        else {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.endX = x;
                this.activeObj.activePoint.startY = y;
                if (this.activeObj.activePoint.endX < this.activeObj.activePoint.startX) {
                    var temp = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = temp;
                    this.dragElement = 'nw-resize';
                }
                if (this.activeObj.activePoint.startY > this.activeObj.activePoint.endY) {
                    var temp = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = temp;
                    this.dragElement = 'se-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.endX > x && this.activeObj.activePoint.startY < y) {
                    width = this.activeObj.activePoint.endX - x;
                    height = y - this.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX -= newScale.x;
                    this.activeObj.activePoint.startY += newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.endX += newScale.x;
                        this.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - this.activeObj.activePoint.endX;
                    height = this.activeObj.activePoint.startY - y;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX += newScale.x;
                    this.activeObj.activePoint.startY -= newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.startY < 0) {
                        this.activeObj.activePoint.endX -= newScale.x;
                        this.activeObj.activePoint.startY += newScale.y;
                    }
                }
            }
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.updateWPoints = function (x, y) {
        var width;
        var height;
        var scale;
        if (this.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.startX = x;
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                if (this.activeObj.activePoint.startX > this.activeObj.activePoint.endX) {
                    var temp = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = temp;
                    this.dragElement = 'e-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.startX < x && this.activeObj.activePoint.endY > y) {
                    width = x - this.activeObj.activePoint.startX;
                    height = this.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX += newScale.x;
                    this.activeObj.activePoint.endY -= newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.endY > this.lowerCanvas.height) {
                        this.activeObj.activePoint.startX -= newScale.x;
                        this.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = this.activeObj.activePoint.startX - x;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX -= newScale.x;
                    this.activeObj.activePoint.endY += newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.endY > this.lowerCanvas.height) {
                        this.activeObj.activePoint.startX += newScale.x;
                        this.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            }
        }
    };
    ImageEditor.prototype.updateEPoints = function (x, y) {
        var width;
        var height;
        var scale;
        if (this.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.endX = x;
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                if (this.activeObj.activePoint.endX < this.activeObj.activePoint.startX) {
                    var temp = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = temp;
                    this.dragElement = 'w-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.endX > x && this.activeObj.activePoint.endY > y) {
                    width = this.activeObj.activePoint.endX - x;
                    height = this.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX -= newScale.x;
                    this.activeObj.activePoint.endY -= newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX += newScale.x;
                        this.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - this.activeObj.activePoint.endX;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX += newScale.x;
                    this.activeObj.activePoint.endY += newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX -= newScale.x;
                        this.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            }
        }
    };
    ImageEditor.prototype.updateSWPoints = function (x, y, maxDimension) {
        var diff;
        var width;
        var height;
        var scale;
        var percentage;
        var prevDiffX = this.diffPoint.x;
        var prevDiffY = this.diffPoint.y;
        if (this.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = this.activeObj.activePoint.startX - x;
                this.diffPoint.y = y - this.activeObj.activePoint.endY;
            }
            else {
                this.diffPoint.x = this.oldPoint.x - x;
                this.diffPoint.y = y - this.oldPoint.y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = diff / 10;
            this.activeObj.activePoint.startX -= (maxDimension.width / 100) * percentage;
            this.activeObj.activePoint.endY += (maxDimension.height / 100) * percentage;
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            var degree = void 0;
            var maxText = this.getMaxText();
            if (this.activeObj.shapeDegree === 0) {
                degree = this.degree;
            }
            else {
                degree = this.degree - this.activeObj.shapeDegree;
            }
            if (degree === 0 || degree === 180) {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.width / maxText.length) * 2;
            }
            else {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.height / maxText.length) * 2;
            }
        }
        else {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.startX = x;
                this.activeObj.activePoint.endY = y;
                if (this.activeObj.activePoint.startX > this.activeObj.activePoint.endX) {
                    var temp = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = temp;
                    this.dragElement = 'se-resize';
                }
                if (this.activeObj.activePoint.endY < this.activeObj.activePoint.startY) {
                    var temp = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = temp;
                    this.dragElement = 'nw-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.startX < x && this.activeObj.activePoint.endY > y) {
                    width = x - this.activeObj.activePoint.startX;
                    height = this.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX += newScale.x;
                    this.activeObj.activePoint.endY -= newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.endY > this.lowerCanvas.height) {
                        this.activeObj.activePoint.startX -= newScale.x;
                        this.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = this.activeObj.activePoint.startX - x;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.startX -= newScale.x;
                    this.activeObj.activePoint.endY += newScale.y;
                    if (this.activeObj.activePoint.startX < 0 || this.activeObj.activePoint.endY > this.lowerCanvas.height) {
                        this.activeObj.activePoint.startX += newScale.x;
                        this.activeObj.activePoint.endY -= newScale.y;
                    }
                }
            }
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.updateSPoints = function (x, y) {
        var width;
        var height;
        var scale;
        if (this.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.endY = y;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
                if (this.activeObj.activePoint.endY < this.activeObj.activePoint.startY) {
                    var temp = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = temp;
                    this.dragElement = 'n-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.endX > x && this.activeObj.activePoint.endY > y) {
                    width = this.activeObj.activePoint.endX - x;
                    height = this.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX -= newScale.x;
                    this.activeObj.activePoint.endY -= newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX += newScale.x;
                        this.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - this.activeObj.activePoint.endX;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX += newScale.x;
                    this.activeObj.activePoint.endY += newScale.x;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX -= newScale.x;
                        this.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            }
        }
    };
    ImageEditor.prototype.updateSEPoints = function (x, y, maxDimension) {
        var diff;
        var width;
        var height;
        var scale;
        var percentage;
        var prevDiffX = this.diffPoint.x;
        var prevDiffY = this.diffPoint.y;
        if (this.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = x - this.activeObj.activePoint.endX;
                this.diffPoint.y = y - this.activeObj.activePoint.endY;
            }
            else {
                this.diffPoint.x = x - this.oldPoint.x;
                this.diffPoint.y = y - this.oldPoint.y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x >= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = diff / 10;
            this.activeObj.activePoint.endX += (maxDimension.width / 50) * percentage;
            this.activeObj.activePoint.endY += (maxDimension.height / 50) * percentage;
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
            var degree = void 0;
            var maxText = this.getMaxText();
            if (this.activeObj.shapeDegree === 0) {
                degree = this.degree;
            }
            else {
                degree = this.degree - this.activeObj.shapeDegree;
            }
            if (degree === 0 || degree === 180) {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.width / maxText.length) * 2;
            }
            else {
                this.activeObj.textSettings.fontSize = (this.activeObj.activePoint.height / maxText.length) * 2;
            }
        }
        else {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (this.currObjType.isCustomCrop || (this.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.activeObj.activePoint.endX = x;
                this.activeObj.activePoint.endY = y;
                if (this.activeObj.activePoint.endX < this.activeObj.activePoint.startX) {
                    var temp = this.activeObj.activePoint.endX;
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.startX = temp;
                    this.dragElement = 'sw-resize';
                }
                if (this.activeObj.activePoint.endY < this.activeObj.activePoint.startY) {
                    var temp = this.activeObj.activePoint.endY;
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.startY = temp;
                    this.dragElement = 'ne-resize';
                }
            }
            else {
                if (this.activeObj.activePoint.endX > x && this.activeObj.activePoint.endY > y) {
                    width = this.activeObj.activePoint.endX - x;
                    height = this.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    var ratio = this.activeObj.shape.split('-');
                    ratio = ratio[1].split(':');
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX -= newScale.x;
                    this.activeObj.activePoint.endY -= newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX += newScale.x;
                        this.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - this.activeObj.activePoint.endX;
                    height = y - this.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    this.activeObj.activePoint.endX += newScale.x;
                    this.activeObj.activePoint.endY += newScale.y;
                    if (this.activeObj.activePoint.endX > this.lowerCanvas.width || this.activeObj.activePoint.endY >
                        this.lowerCanvas.height) {
                        this.activeObj.activePoint.endX -= newScale.x;
                        this.activeObj.activePoint.endY -= newScale.y;
                    }
                }
            }
            this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
            this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.getScaleRatio = function (scale) {
        var point = { x: scale, y: scale };
        if (!this.currObjType.isCustomCrop && this.activeObj.shape !== 'crop-circle' && this.activeObj.shape !== 'crop-square') {
            var ratio = this.activeObj.shape.split('-');
            ratio = ratio[1].split(':');
            var newScale = scale / (parseInt(ratio[1], 10));
            point.x = newScale * (parseInt(ratio[0], 10));
            point.y = newScale * (parseInt(ratio[1], 10));
        }
        return point;
    };
    ImageEditor.prototype.getMaxText = function (isTextBox) {
        var text = isTextBox ? this.textBox.value : this.activeObj.keyHistory;
        var maxi;
        var rows = text.split('\n');
        var maxStr = rows[0].length;
        var maxText = rows[0];
        for (var i = 1; i < rows.length; i++) {
            maxi = rows[i].length;
            if (maxi > maxStr) {
                maxText = rows[i];
                maxStr = maxi;
            }
        }
        return maxText;
    };
    ImageEditor.prototype.setDragLimit = function () {
        if (this.factor === 1 && this.activeObj.activePoint !== undefined && this.activeObj.shape !== 'text') {
            if (this.activeObj.activePoint.startX < 0) {
                this.activeObj.activePoint.startX = 0;
                this.activeObj.activePoint.endX = this.activeObj.activePoint.width;
            }
            else if (this.activeObj.activePoint.endX > this.lowerCanvas.width) {
                this.activeObj.activePoint.endX = this.lowerCanvas.width;
                this.activeObj.activePoint.startX = this.lowerCanvas.width - this.activeObj.activePoint.width;
            }
            if (this.activeObj.activePoint.startY < 0) {
                this.activeObj.activePoint.startY = 0;
                this.activeObj.activePoint.endY = this.activeObj.activePoint.height;
            }
            else if (this.activeObj.activePoint.endY > this.lowerCanvas.height) {
                this.activeObj.activePoint.endY = this.lowerCanvas.height;
                this.activeObj.activePoint.startY = this.lowerCanvas.height - this.activeObj.activePoint.height;
            }
        }
    };
    ImageEditor.prototype.lineDraw = function (ratio) {
        if (this.activeObj.activePoint.height < 10 * ratio.height) {
            this.activeObj.activePoint.startY -= 10 * ratio.height;
            this.activeObj.activePoint.endY += 10 * ratio.height;
            this.activeObj.lineDraw = 'horizontal';
        }
        else if (this.activeObj.activePoint.width < 10 * ratio.width) {
            this.activeObj.activePoint.startX -= 10 * ratio.width;
            this.activeObj.activePoint.endX += 10 * ratio.width;
            this.activeObj.lineDraw = 'vertical';
        }
        else if (this.currObjType.isInitialLine) {
            this.activeObj.lineDraw = 'normal';
            this.currObjType.isInitialLine = false;
        }
        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
    };
    ImageEditor.prototype.shapeCircle = function (canvasDraw, selectionWidth, selectionHeight) {
        var ratio = this.calcRatio();
        canvasDraw.strokeStyle = this.themeColl[this.theme]['primaryColor'];
        canvasDraw.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        canvasDraw.fillStyle = 'rgb(0, 0, 0, 0.5)';
        canvasDraw.fillRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        var tempWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (2 * (ratio.width + ratio.height)) / this.factor;
        canvasDraw.beginPath();
        canvasDraw.ellipse(this.activeObj.horTopLine.startX + (selectionWidth / 2), this.activeObj.horTopLine.startY
            + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
        canvasDraw.stroke();
        canvasDraw.closePath();
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(((this.activeObj.activePoint.endX - this.activeObj.activePoint.startX) / 2) + this.activeObj.activePoint.startX, ((this.activeObj.activePoint.endY - this.activeObj.activePoint.startY) / 2) + this.activeObj.activePoint.startY, (this.activeObj.activePoint.width / 2), 0, Math.PI * 2);
        canvasDraw.closePath();
        canvasDraw.clip();
        canvasDraw.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        canvasDraw.restore();
        canvasDraw.lineWidth = tempWidth;
        this.drawOuterSelection(canvasDraw, null, true);
        this.currObjType.shape = '';
    };
    ImageEditor.prototype.drawOuterSelection = function (canvasDraw, isInitialDraw, isCropCircle) {
        var splitWords;
        var ratio = this.calcRatio();
        canvasDraw.lineWidth = (0.5 * (ratio.width + ratio.height)) / this.factor;
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        var tempObj = extend({}, this.activeObj, {}, true);
        if (this.factor !== 1) {
            if (isInitialDraw) {
                tempObj = this.getZoomShape(tempObj, ratio);
            }
        }
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (((splitWords !== undefined && splitWords[0] === 'crop') || this.activeObj.shape === undefined) && !isCropCircle) {
            this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.5)';
            this.upperContext.fillRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.upperContext.clearRect(this.activeObj.activePoint.startX, this.activeObj.activePoint.startY, this.activeObj.activePoint.width, this.activeObj.activePoint.height);
        }
        canvasDraw.strokeStyle = this.themeColl[this.theme]['primaryColor'];
        canvasDraw.fillStyle = this.themeColl[this.theme]['secondaryColor'];
        if (this.activeObj.shape !== 'rectangle') {
            canvasDraw.beginPath();
            canvasDraw.rect(tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height);
            canvasDraw.stroke();
            canvasDraw.closePath();
        }
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        canvasDraw.moveTo(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY);
        canvasDraw.arc(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY, tempObj.topLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY);
        canvasDraw.arc(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY, tempObj.topRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY);
        canvasDraw.arc(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY, tempObj.bottomLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY);
        canvasDraw.arc(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY, tempObj.bottomRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        canvasDraw.lineWidth /= 2;
        if ((splitWords === undefined || splitWords[0] !== 'crop') && this.activeObj.shape !== 'text') {
            this.drawCenterCircles(canvasDraw);
        }
        this.activeObj = extend({}, tempObj, {}, true);
    };
    ImageEditor.prototype.getZoomShape = function (tempObj, ratio) {
        var obj = extend({}, tempObj, {}, true);
        obj.activePoint.startX = (obj.activePoint.startX / this.factor) * ratio.width;
        obj.activePoint.startY = (obj.activePoint.startY / this.factor) * ratio.height;
        obj.activePoint.endX = (obj.activePoint.endX / this.factor) * ratio.width;
        obj.activePoint.endY = (obj.activePoint.endY / this.factor) * ratio.height;
        obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
        obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
        this.updateActiveObject(ratio, obj.activePoint, obj);
        return obj;
    };
    ImageEditor.prototype.drawObject = function (canvas, obj, isInitialDraw, isCropRatio, points) {
        var canvasDraw;
        if (canvas.toLowerCase() === 'original') {
            canvasDraw = this.lowerContext;
        }
        else {
            canvasDraw = this.upperContext;
        }
        this.setDragLimit();
        var ratio = this.calcRatio();
        if (this.currObjType.isLine && canvas !== 'original' && !obj) {
            this.lineDraw(ratio);
        }
        var splitWords = this.currObjType.shape.split('-');
        if (splitWords[0].toLowerCase() === 'crop' && isCropRatio) {
            this.drawCropRatio();
        }
        if (points) {
            this.activeObj.activePoint.startX = points.startX;
            this.activeObj.activePoint.startY = points.startY;
            this.activeObj.activePoint.endX = points.endX;
            this.activeObj.activePoint.endY = points.endY;
            this.activeObj.activePoint.width = points.width;
            this.activeObj.activePoint.height = points.height;
        }
        if (isNullOrUndefined(this.activeObj.strokeSettings)) {
            this.activeObj.strokeSettings = this.strokeSettings;
        }
        if (isNullOrUndefined(this.activeObj.strokeSettings.strokeWidth)) {
            this.activeObj.strokeSettings.strokeWidth = 2 * (ratio.width + ratio.height) / this.factor;
        }
        if (obj) {
            this.activeObj = extend({}, obj, {}, true);
            if (this.factor !== 1) {
                this.updateActiveObject(ratio);
            }
        }
        else {
            this.updateActiveObject(ratio);
        }
        if (this.currObjType.isText) {
            this.activeObj.keyHistory = this.keyHistory;
        }
        if (canvas.toLowerCase() !== 'original') {
            var splitWords_1;
            var isCrop = false;
            if (this.activeObj.shape) {
                splitWords_1 = this.activeObj.shape.split('-');
                if (splitWords_1[0] === 'crop') {
                    isCrop = true;
                }
            }
            if (isCrop) {
                this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.5)';
                this.upperContext.fillRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.upperContext.clearRect(this.activeObj.activePoint.startX + ratio.width, this.activeObj.activePoint.startY + ratio.height, this.activeObj.activePoint.width - ratio.width, this.activeObj.activePoint.height - ratio.height);
            }
            this.drawOuterSelection(canvasDraw, isInitialDraw);
        }
        this.currObjType.isActiveObj = true;
        if (obj) {
            this.drawShapeObj(canvas, obj.shape);
        }
        else if (this.keyHistory !== '' && this.currObjType.isText) {
            this.drawShapeObj(canvas, 'text');
        }
        else if (this.activeObj.shape) {
            this.drawShapeObj(canvas, this.activeObj.shape);
        }
        else {
            this.drawShapeObj(canvas, undefined);
        }
    };
    ImageEditor.prototype.updateActiveObject = function (ratio, actPoint, obj, isMouseMove) {
        actPoint = actPoint ? actPoint : extend({}, this.activeObj.activePoint, {}, true);
        obj = obj ? obj : extend({}, this.activeObj, {}, true);
        var horCircleWidth = actPoint.width / 2;
        var verCircleHeight = actPoint.height / 2;
        var radius = 7.5;
        obj.horTopLine = { startX: actPoint.startX, startY: actPoint.startY,
            endX: actPoint.endX, endY: actPoint.endY };
        obj.horBottomLine = { startX: actPoint.startX, startY: actPoint.endY,
            endX: actPoint.endX, endY: actPoint.endY };
        obj.verLeftLine = { startX: actPoint.startX, startY: actPoint.startY,
            endX: actPoint.startX, endY: actPoint.endY };
        obj.verRightLine = { startX: actPoint.endX, startY: actPoint.startY,
            endX: actPoint.endX, endY: actPoint.endY };
        obj.topLeftCircle = { startX: actPoint.startX, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.topCenterCircle = { startX: actPoint.startX + horCircleWidth, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.topRightCircle = { startX: actPoint.endX, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.centerLeftCircle = { startX: actPoint.startX, startY: actPoint.startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.centerRightCircle = { startX: actPoint.endX, startY: actPoint.startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.bottomLeftCircle = { startX: actPoint.startX, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.bottomCenterCircle = { startX: actPoint.startX + horCircleWidth, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.bottomRightCircle = { startX: actPoint.endX, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor : 0 };
        obj.activePoint = actPoint;
        if (isNullOrUndefined(isMouseMove)) {
            this.activeObj = extend({}, obj, {}, true);
        }
    };
    ImageEditor.prototype.drawShapeObj = function (canvas, shape) {
        var currentShape = shape !== undefined ? shape : this.currObjType.shape;
        this.currObjType.shape = currentShape;
        var canvasDraw;
        if (canvas.toLowerCase() === 'original') {
            canvasDraw = this.lowerContext;
        }
        else {
            canvasDraw = this.upperContext;
        }
        if (this.currObjType.shape.toLowerCase() === 'rectangle' || this.currObjType.shape.toLowerCase() === 'ellipse'
            || this.currObjType.shape.toLowerCase() === 'line') {
            this.activeObj.shape = this.currObjType.shape;
        }
        canvasDraw.strokeStyle = this.activeObj.strokeSettings.strokeColor;
        if (shape === 'text' || shape === 'freehanddraw') {
            canvasDraw.fillStyle = this.activeObj.strokeSettings.strokeColor;
        }
        else {
            canvasDraw.fillStyle = this.activeObj.strokeSettings.fillColor;
        }
        var horLineWidth = this.activeObj.activePoint.width / 3;
        var verLineHeight = this.activeObj.activePoint.height / 3;
        var selectionWidth = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        var selectionHeight = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        switch (this.currObjType.shape.toLowerCase()) {
            case 'rectangle':
                this.drawSquareLines(canvasDraw);
                if (canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'ellipse':
                canvasDraw.beginPath();
                canvasDraw.ellipse(this.activeObj.activePoint.startX + (selectionWidth / 2), this.activeObj.activePoint.startY + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
                if (this.activeObj.strokeSettings.fillColor !== '') {
                    canvasDraw.fillStyle = this.activeObj.strokeSettings.fillColor;
                    canvasDraw.fill();
                }
                canvasDraw.ellipse(this.activeObj.activePoint.startX + (selectionWidth / 2), this.activeObj.activePoint.startY + (selectionHeight / 2), (selectionWidth / 2) - (this.activeObj.strokeSettings.strokeWidth), (selectionHeight / 2) - (this.activeObj.strokeSettings.strokeWidth), 0, 0, 2 * Math.PI, false);
                canvasDraw.fillStyle = this.activeObj.strokeSettings.strokeColor;
                canvasDraw.fill('evenodd');
                canvasDraw.closePath();
                if (canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'crop-circle':
                this.shapeCircle(canvasDraw, selectionWidth, selectionHeight);
                break;
            case 'line':
                this.shapeLine(canvasDraw, selectionWidth, selectionHeight);
                if (canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'text':
                this.shapeText(canvasDraw);
                break;
            case 'crop-square':
            case 'crop-3:4':
            case 'crop-4:3':
            case 'crop-6:9':
            case 'crop-9:6':
            case 'crop-9:16':
            case 'crop-16:9':
                this.drawSelection(horLineWidth, verLineHeight);
                this.currObjType.shape = '';
                break;
            default:
                this.drawSelection(horLineWidth, verLineHeight);
                break;
        }
    };
    ImageEditor.prototype.shapeLine = function (canvasDraw, selectionWidth, selectionHeight) {
        var startX;
        var startY;
        var endX;
        var endY;
        var degree;
        if (this.activeObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - this.activeObj.shapeDegree;
        }
        if (degree === 0 || degree % 180 === 0) {
            startX = this.activeObj.activePoint.startX;
            startY = this.activeObj.activePoint.startY + (selectionHeight / 2);
            endX = this.activeObj.activePoint.endX;
            endY = this.activeObj.activePoint.startY + (selectionHeight / 2);
        }
        else {
            startX = this.activeObj.activePoint.startX + (selectionWidth / 2);
            startY = this.activeObj.activePoint.startY;
            endX = this.activeObj.activePoint.startX + (selectionWidth / 2);
            endY = this.activeObj.activePoint.endY;
        }
        var tempLineWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (this.activeObj.strokeSettings.strokeWidth) / Math.abs(this.factor);
        canvasDraw.beginPath();
        switch (this.activeObj.lineDraw.toLowerCase()) {
            case 'horizontal':
            case 'vertical':
                canvasDraw.moveTo(startX, startY);
                canvasDraw.lineTo(endX, endY);
                break;
            case 'normal':
                canvasDraw.moveTo(this.activeObj.horTopLine.startX, this.activeObj.horTopLine.startY);
                canvasDraw.lineTo(this.activeObj.horBottomLine.endX, this.activeObj.horBottomLine.endY);
                break;
        }
        canvasDraw.stroke();
        canvasDraw.lineWidth = tempLineWidth;
    };
    ImageEditor.prototype.shapeText = function (canvasDraw) {
        var rows = this.activeObj.keyHistory.split('\n');
        var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
        var lineHeight = ((height * rows.length) - (this.activeObj.textSettings.fontSize * rows.length)) / rows.length;
        for (var i = 0; i < rows.length; i++) {
            var text = rows[i];
            var yPoint = ((i + 1) * this.activeObj.textSettings.fontSize * 0.85) + (i * lineHeight);
            if (this.degree === -360) {
                this.degree = 0;
            }
            if (this.degree === 0 || this.degree === 180) {
                if (this.activeObj.textSettings.fontSize > this.activeObj.activePoint.height) {
                    this.activeObj.textSettings.fontSize = this.activeObj.activePoint.height -
                        (this.activeObj.activePoint.height * 0.1);
                }
            }
            else {
                if (this.activeObj.textSettings.fontSize > this.activeObj.activePoint.width) {
                    this.activeObj.textSettings.fontSize = this.activeObj.activePoint.width -
                        (this.activeObj.activePoint.width * 0.1);
                }
            }
            canvasDraw.strokeStyle = this.activeObj.strokeSettings.strokeColor;
            canvasDraw.fillStyle = this.activeObj.strokeSettings.strokeColor;
            var textStyle = '';
            if (this.activeObj.textSettings.bold) {
                textStyle = 'bold ';
            }
            if (this.activeObj.textSettings.italic) {
                textStyle = 'italic ';
            }
            if (this.activeObj.textSettings.bold && this.activeObj.textSettings.italic) {
                textStyle = 'italic bold ';
            }
            canvasDraw.font = textStyle + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
            if (this.activeObj.flipObjColl.length === 4) {
                this.activeObj.flipObjColl = [];
            }
            for (var j = 0; j < this.activeObj.flipObjColl.length; j++) {
                if (this.activeObj.flipObjColl[j].toLowerCase() === 'horizontal') {
                    this.lowerContext.translate(this.lowerContext.canvas.width, 0);
                    this.lowerContext.scale(-1, 1);
                    this.upperContext.translate(this.upperContext.canvas.width, 0);
                    this.upperContext.scale(-1, 1);
                    this.updateActPoint('horizontal');
                }
                else if (this.activeObj.flipObjColl[j].toLowerCase() === 'vertical') {
                    this.lowerContext.translate(0, this.lowerContext.canvas.height);
                    this.lowerContext.scale(1, -1);
                    this.upperContext.translate(0, this.upperContext.canvas.height);
                    this.upperContext.scale(1, -1);
                    this.updateActPoint('vertical');
                }
            }
            if (this.activeObj.shapeDegree !== this.degree) {
                this.rotateText(canvasDraw);
            }
            else {
                canvasDraw.fillText(text, this.activeObj.activePoint.startX + this.activeObj.textSettings.fontSize * 0.1, this.activeObj.activePoint.startY + yPoint);
            }
            for (var k = 0; k < this.activeObj.flipObjColl.length; k++) {
                if (this.activeObj.flipObjColl[k].toLowerCase() === 'horizontal') {
                    this.lowerContext.translate(this.lowerContext.canvas.width, 0);
                    this.lowerContext.scale(-1, 1);
                    this.upperContext.translate(this.upperContext.canvas.width, 0);
                    this.upperContext.scale(-1, 1);
                    this.updateActPoint('horizontal');
                }
                else if (this.activeObj.flipObjColl[k].toLowerCase() === 'vertical') {
                    this.lowerContext.translate(0, this.lowerContext.canvas.height);
                    this.lowerContext.scale(1, -1);
                    this.upperContext.translate(0, this.upperContext.canvas.height);
                    this.upperContext.scale(1, -1);
                    this.updateActPoint('vertical');
                }
            }
        }
        this.currObjType.isText = false;
    };
    ImageEditor.prototype.updateActPoint = function (degree) {
        var ratio = this.calcRatio();
        if (degree.toLowerCase() === 'horizontal') {
            if (this.activeObj.activePoint.startX <= this.lowerCanvas.width / 2) {
                this.activeObj.activePoint.startX = this.lowerCanvas.width / 2 + ((this.lowerCanvas.width / 2) -
                    this.activeObj.activePoint.endX);
                this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + this.activeObj.activePoint.width;
                this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
            }
            else if (this.activeObj.activePoint.startX >= this.lowerCanvas.width / 2) {
                this.activeObj.activePoint.startX = this.lowerCanvas.width - this.activeObj.activePoint.endX;
                this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + this.activeObj.activePoint.width;
                this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
            }
        }
        else if (degree.toLowerCase() === 'vertical') {
            if (this.activeObj.activePoint.startY <= this.lowerCanvas.height / 2) {
                this.activeObj.activePoint.startY = this.lowerCanvas.height / 2 + ((this.lowerCanvas.height / 2) -
                    this.activeObj.activePoint.endY);
                this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + this.activeObj.activePoint.height;
                this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
            }
            else if (this.activeObj.activePoint.startY >= this.lowerCanvas.height / 2) {
                this.activeObj.activePoint.startY = this.lowerCanvas.height - this.activeObj.activePoint.endY;
                this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + this.activeObj.activePoint.height;
                this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
            }
        }
    };
    ImageEditor.prototype.drawSquareLines = function (canvasDraw) {
        var splitWords;
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (splitWords[0] === 'crop') {
            canvasDraw.strokeStyle = '#fff';
        }
        else {
            canvasDraw.strokeStyle = this.activeObj.strokeSettings.strokeColor;
        }
        canvasDraw.beginPath();
        canvasDraw.rect(this.activeObj.activePoint.startX, this.activeObj.activePoint.startY, this.activeObj.activePoint.width, this.activeObj.activePoint.height);
        if (this.activeObj.strokeSettings.fillColor !== '') {
            canvasDraw.fillStyle = this.activeObj.strokeSettings.fillColor;
            canvasDraw.fill();
        }
        canvasDraw.rect(this.activeObj.activePoint.startX + this.activeObj.strokeSettings.strokeWidth, this.activeObj.activePoint.startY + this.activeObj.strokeSettings.strokeWidth, this.activeObj.activePoint.width - (2 * this.activeObj.strokeSettings.strokeWidth), this.activeObj.activePoint.height - (2 * this.activeObj.strokeSettings.strokeWidth));
        canvasDraw.fillStyle = this.activeObj.strokeSettings.strokeColor;
        canvasDraw.fill('evenodd');
        canvasDraw.closePath();
    };
    ImageEditor.prototype.drawSelection = function (horLineWidth, verLineHeight) {
        this.upperContext.strokeStyle = this.themeColl[this.theme]['primaryColor'];
        this.upperContext.beginPath();
        this.activeObj.horTopInnerLine = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY +
                verLineHeight, endX: this.activeObj.activePoint.endX, endY: this.activeObj.activePoint.endY + verLineHeight };
        this.activeObj.horBottomInnerLine = { startX: this.activeObj.activePoint.startX, startY: this.activeObj.activePoint.startY +
                (2 * verLineHeight), endX: this.activeObj.activePoint.endX, endY: this.activeObj.activePoint.endY + (2 * verLineHeight) };
        this.activeObj.verLeftInnerLine = { startX: this.activeObj.activePoint.startX + horLineWidth,
            startY: this.activeObj.activePoint.startY, endX: this.activeObj.activePoint.startX + horLineWidth,
            endY: this.activeObj.activePoint.endY };
        this.activeObj.verRightInnerLine = { startX: this.activeObj.activePoint.startX + (2 * horLineWidth),
            startY: this.activeObj.activePoint.startY, endX: this.activeObj.activePoint.startX + (2 * horLineWidth),
            endY: this.activeObj.activePoint.endY };
        this.upperContext.moveTo(this.activeObj.horTopInnerLine.startX, this.activeObj.horTopInnerLine.startY);
        this.upperContext.lineTo(this.activeObj.horTopInnerLine.endX, this.activeObj.horTopInnerLine.startY);
        this.upperContext.moveTo(this.activeObj.horBottomInnerLine.startX, this.activeObj.horBottomInnerLine.startY);
        this.upperContext.lineTo(this.activeObj.horBottomInnerLine.endX, this.activeObj.horBottomInnerLine.startY);
        this.upperContext.moveTo(this.activeObj.verLeftInnerLine.startX, this.activeObj.verLeftInnerLine.startY);
        this.upperContext.lineTo(this.activeObj.verLeftInnerLine.endX, this.activeObj.verLeftInnerLine.endY);
        this.upperContext.moveTo(this.activeObj.verRightInnerLine.startX, this.activeObj.verRightInnerLine.startY);
        this.upperContext.lineTo(this.activeObj.verRightInnerLine.endX, this.activeObj.verRightInnerLine.endY);
        this.upperContext.stroke();
        this.upperContext.closePath();
    };
    ImageEditor.prototype.drawCenterCircles = function (canvasDraw) {
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        canvasDraw.moveTo(this.activeObj.topCenterCircle.startX, this.activeObj.topCenterCircle.startY);
        canvasDraw.arc(this.activeObj.topCenterCircle.startX, this.activeObj.topCenterCircle.startY, this.activeObj.topCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(this.activeObj.centerLeftCircle.startX, this.activeObj.centerLeftCircle.startY);
        canvasDraw.arc(this.activeObj.centerLeftCircle.startX, this.activeObj.centerLeftCircle.startY, this.activeObj.centerLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(this.activeObj.centerRightCircle.startX, this.activeObj.centerRightCircle.startY);
        canvasDraw.arc(this.activeObj.centerRightCircle.startX, this.activeObj.centerRightCircle.startY, this.activeObj.centerRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(this.activeObj.bottomCenterCircle.startX, this.activeObj.bottomCenterCircle.startY);
        canvasDraw.arc(this.activeObj.bottomCenterCircle.startX, this.activeObj.bottomCenterCircle.startY, this.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        canvasDraw.lineWidth /= 2;
    };
    ImageEditor.prototype.findTarget = function (x, y, type) {
        var bbox = this.upperCanvas.getBoundingClientRect();
        var ratio = this.calcRatio();
        if (this.factor === 1) {
            x = (x - bbox.left) * ratio.width;
            y = (y - bbox.top) * ratio.height;
        }
        else {
            x = (x - bbox.left) + ((this.pannStart.startX) / ratio.width * this.factor);
            y = (y - bbox.top) + ((this.pannStart.startY) / ratio.height * this.factor);
        }
        if (type.toLowerCase() === 'mousedown' || type.toLowerCase() === 'touchstart') {
            var splitWords = void 0;
            var isCrop = false;
            if (this.activeObj.shape) {
                splitWords = this.activeObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    isCrop = true;
                }
            }
            this.findTargetObj(x, y, ratio, isCrop);
            this.updateCursorStyles(x, y, ratio, type);
        }
        else {
            switch (this.dragElement.toLowerCase()) {
                case 'nw-resize':
                    this.activeObj.topLeftCircle.startX = x;
                    this.activeObj.topLeftCircle.startY = y;
                    break;
                case 'n-resize':
                    this.activeObj.topCenterCircle.startX = x;
                    this.activeObj.topCenterCircle.startY = y;
                    break;
                case 'ne-resize':
                    this.activeObj.topRightCircle.startX = x;
                    this.activeObj.topRightCircle.startY = y;
                    break;
                case 'w-resize':
                    this.activeObj.centerLeftCircle.startX = x;
                    this.activeObj.centerLeftCircle.startY = y;
                    break;
                case 'e-resize':
                    this.activeObj.centerRightCircle.startX = x;
                    this.activeObj.centerRightCircle.startY = y;
                    break;
                case 'sw-resize':
                    this.activeObj.bottomLeftCircle.startX = x;
                    this.activeObj.bottomLeftCircle.startY = y;
                    break;
                case 's-resize':
                    this.activeObj.bottomCenterCircle.startX = x;
                    this.activeObj.bottomCenterCircle.startY = y;
                    break;
                case 'se-resize':
                    this.activeObj.bottomRightCircle.startX = x;
                    this.activeObj.bottomRightCircle.startY = y;
                    break;
                default:
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    break;
            }
        }
    };
    ImageEditor.prototype.findTargetObj = function (x, y, ratio, isCrop) {
        if (this.objColl.length !== 0 && !this.currObjType.isCustomCrop && !isCrop) {
            var diffX = 0;
            var i = void 0;
            for (var index = 0; index < this.objColl.length; index++) {
                var actObj = extend({}, this.objColl[index], {}, true);
                if (this.factor !== 1) {
                    actObj = this.setCursorForZoomState(actObj, ratio);
                }
                if (x >= (actObj.activePoint.startX - actObj.topLeftCircle.radius) &&
                    x <= (actObj.activePoint.endX + actObj.topLeftCircle.radius) &&
                    y >= (actObj.activePoint.startY - actObj.topLeftCircle.radius) &&
                    y <= (actObj.activePoint.endY + actObj.topLeftCircle.radius)) {
                    if (diffX === 0 || diffX > x - actObj.activePoint.startX) {
                        diffX = x - this.objColl[index].activePoint.startX;
                        i = index;
                    }
                }
            }
            if (isNullOrUndefined(i)) {
                this.refreshActiveObj();
                return;
            }
            this.currObjType.isCustomCrop = false;
            var temp = this.activeObj = extend({}, this.objColl[i], {}, true);
            this.objColl.splice(i, 1);
            this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
            this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
            if (this.degree === 0) {
                this.inMemoryContext.putImageData(this.imgDataColl[0].value, 0, 0);
            }
            else {
                this.inMemoryCanvas.width = this.currImgData.width;
                this.inMemoryCanvas.height = this.currImgData.height;
                this.inMemoryContext.putImageData(this.currImgData, 0, 0);
            }
            if (this.flipState !== '') {
                this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
                this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
                this.inMemoryCanvas.width = this.currImgData.width;
                this.inMemoryCanvas.height = this.currImgData.height;
                this.inMemoryContext.putImageData(this.currImgData, 0, 0);
            }
            this.setActivePoint();
            this.upperContext.drawImage(this.inMemoryCanvas, 0, 0);
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
            this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            for (var j = 0; j < this.objColl.length; j++) {
                if (this.objColl[j].shape === 'text' && this.objColl[j].shapeFlip !== this.currFlipState) {
                    this.objColl[j].flippedText = true;
                }
                this.apply(this.objColl[j].shape, this.objColl[j]);
            }
            this.activeObj = extend({}, temp, {}, true);
            var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
            if (this.factor !== 1 && (this.activeObj.activePoint.startX < this.pannStart.startX || this.activeObj.activePoint.startY <
                this.pannStart.startY) || (this.activeObj.activePoint.endX > endPoint.x || this.activeObj.activePoint.endY > endPoint.y)) {
                this.allowDrag = true;
            }
            this.tempStrokeSettings = extend({}, this.activeObj.strokeSettings, {}, true);
            this.tempTextSettings = extend({}, this.activeObj.textSettings, {}, true);
            if (this.activeObj.shape === 'text' && this.activeObj.shapeFlip !== this.currFlipState) {
                this.activeObj.flippedText = true;
            }
            if (this.activeObj.activePoint) {
                this.drawObject('duplicate', this.activeObj);
            }
            var shapeChangingArgs = { action: 'select', previousShapeSettings: this.activeObj, currentShapeSettings: this.activeObj };
            this.trigger('shapeChanging', shapeChangingArgs);
        }
    };
    ImageEditor.prototype.updateCursorStyles = function (x, y, ratio, type) {
        var isResize = false;
        if (this.activeObj.keyHistory !== '' && this.activeObj.shape === undefined && !this.currObjType.isCustomCrop &&
            !this.currObjType.isLine && this.currObjType.isText) {
            this.activeObj.shape = 'text';
        }
        var actObj = extend({}, this.activeObj, {}, true);
        if (isNullOrUndefined(actObj.topLeftCircle)) {
            return;
        }
        if (this.factor !== 1) {
            actObj = this.setCursorForZoomState(actObj, ratio, true);
        }
        if (x >= (actObj.topLeftCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.topLeftCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.topLeftCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.topLeftCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'nw-resize') {
            actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;
            this.upperCanvas.style.cursor = 'nw-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.topCenterCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.topCenterCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.topCenterCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.topCenterCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'n-resize') {
            actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;
            this.upperCanvas.style.cursor = 'n-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.topRightCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.topRightCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.topRightCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.topRightCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'ne-resize') {
            actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;
            this.upperCanvas.style.cursor = 'ne-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.centerLeftCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.centerLeftCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.centerLeftCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.centerLeftCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'w-resize') {
            actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
            this.upperCanvas.style.cursor = 'w-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.centerRightCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.centerRightCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.centerRightCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.centerRightCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'e-resize') {
            actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
            this.upperCanvas.style.cursor = 'e-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.bottomLeftCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.bottomLeftCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.bottomLeftCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.bottomLeftCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'sw-resize') {
            actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;
            this.upperCanvas.style.cursor = 'sw-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.bottomCenterCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.bottomCenterCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.bottomCenterCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.bottomCenterCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 's-resize') {
            actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;
            this.upperCanvas.style.cursor = 's-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else if (x >= (actObj.bottomRightCircle.startX - actObj.topLeftCircle.radius) &&
            x <= (actObj.bottomRightCircle.startX + actObj.topLeftCircle.radius) &&
            y >= (actObj.bottomRightCircle.startY - actObj.topLeftCircle.radius) &&
            y <= (actObj.bottomRightCircle.startY + actObj.topLeftCircle.radius) && this.dragElement !== 'se-resize') {
            actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;
            this.upperCanvas.style.cursor = 'se-resize';
            isResize = true;
            this.dragElement = this.upperCanvas.style.cursor;
        }
        else {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
        this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;
        if (type === 'touchstart') {
            if (isResize || (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX
                && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY)) {
                this.currObjType.isDragging = true;
            }
        }
        else {
            this.currObjType.isDragging = true;
        }
    };
    ImageEditor.prototype.drawCropRatio = function () {
        var x;
        var y;
        switch (this.currObjType.shape.toLowerCase()) {
            case 'crop-square':
            case 'crop-circle':
                this.setDragDirection();
                if (this.lowerCanvas.width > this.lowerCanvas.height) {
                    this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
                    this.activeObj.activePoint.width = this.activeObj.activePoint.height;
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + this.activeObj.activePoint.width;
                }
                else {
                    this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.height = this.activeObj.activePoint.width;
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + this.activeObj.activePoint.height;
                }
                break;
            case 'crop-3:2':
                x = 3;
                y = 2;
                break;
            case 'crop-4:3':
                x = 4;
                y = 3;
                break;
            case 'crop-5:4':
                x = 5;
                y = 4;
                break;
            case 'crop-7:5':
                x = 7;
                y = 5;
                break;
            case 'crop-16:9':
                x = 16;
                y = 9;
                break;
        }
        if (x !== undefined && y !== undefined) {
            this.calcShapeRatio(x, y);
        }
    };
    ImageEditor.prototype.setDragDirection = function () {
        var ratio = this.calcRatio();
        var arcRadius = (7.5 * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor;
        if (this.lowerCanvas.width > this.lowerCanvas.height) {
            if (this.factor === 1) {
                this.activeObj.activePoint.startX = this.dragPoint.startX = ((this.lowerCanvas.width / 2) - (this.lowerCanvas.height / 2))
                    + arcRadius;
                this.activeObj.activePoint.startY = this.dragPoint.startY = ((this.lowerCanvas.height / 2) - (this.lowerCanvas.height / 2))
                    + arcRadius;
                this.activeObj.activePoint.endX = ((this.lowerCanvas.width / 2) + (this.lowerCanvas.height / 2)) - arcRadius;
                this.activeObj.activePoint.endY = ((this.lowerCanvas.height / 2) + (this.lowerCanvas.height / 2)) - arcRadius;
            }
            else {
                var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                var visibleWidth = endPoint.x - this.pannStart.startX;
                var visibleHeight = endPoint.y - this.pannStart.startY;
                var centerX = (this.dragPoint.startX = visibleWidth / 2) + this.pannStart.startX;
                var centerY = this.dragPoint.startY = visibleHeight / 2;
                this.activeObj.activePoint.startX = (centerX - centerY) + arcRadius;
                this.activeObj.activePoint.startY = (this.pannStart.startY) + arcRadius;
                this.activeObj.activePoint.endX = (this.activeObj.activePoint.startX + visibleHeight) - arcRadius;
                this.activeObj.activePoint.endY = (this.activeObj.activePoint.startY + visibleHeight) - (2 * arcRadius);
            }
        }
        else {
            if (this.factor === 1) {
                this.activeObj.activePoint.startY = this.dragPoint.startX = ((this.lowerCanvas.height / 2) - (this.lowerCanvas.width) / 2)
                    + arcRadius;
                this.activeObj.activePoint.endY = ((this.lowerCanvas.height / 2) + (this.lowerCanvas.width) / 2) - arcRadius;
                this.activeObj.activePoint.startX = this.dragPoint.startX = arcRadius;
                this.activeObj.activePoint.endX = this.lowerCanvas.width - arcRadius;
            }
            else {
                var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                var visibleWidth = endPoint.x - this.pannStart.startX;
                var visibleHeight = endPoint.y - this.pannStart.startY;
                var centerX = this.dragPoint.startX = visibleWidth / 2;
                var centerY = (this.dragPoint.startY = visibleHeight / 2) + this.pannStart.startY;
                this.activeObj.activePoint.startX = this.pannStart.startX + arcRadius;
                this.activeObj.activePoint.startY = (centerY - centerX) + arcRadius;
                this.activeObj.activePoint.endX = (this.activeObj.activePoint.startX + visibleWidth) - arcRadius;
                this.activeObj.activePoint.endY = (this.activeObj.activePoint.startY + visibleWidth) - arcRadius;
            }
        }
    };
    ImageEditor.prototype.calcShapeRatio = function (x, y) {
        var ratio = this.calcRatio();
        var arcRadius = (7.5 * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor;
        var originalWidth = this.factor === 1 ? this.lowerCanvas.width : this.lowerCanvas.width / this.factor;
        var originalHeight = this.factor === 1 ? this.lowerCanvas.height : this.lowerCanvas.height / this.factor;
        var presetRatio = x / y;
        var standardSize = originalWidth >= originalHeight ? originalWidth : originalHeight;
        var width = standardSize * presetRatio;
        var height = standardSize;
        var scaleWidth = this.getScale(width, originalWidth);
        var snippetArray = [];
        for (var i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray.push(width * scaleWidth);
            }
            else {
                snippetArray.push(height * scaleWidth);
            }
        }
        width = snippetArray[0];
        height = snippetArray[1];
        var scaleHeight = this.getScale(height, originalHeight);
        var snippetArray1 = [];
        for (var i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray1.push(width * scaleHeight);
            }
            else {
                snippetArray1.push(height * scaleHeight);
            }
        }
        width = snippetArray1[0];
        height = snippetArray1[1];
        this.activeObj.activePoint.width = width;
        this.activeObj.activePoint.height = height;
        this.activeObj.activePoint.startX = (this.dragPoint.startX = (originalWidth - width) / 2) + arcRadius;
        this.activeObj.activePoint.startY = (this.dragPoint.startY = (originalHeight - height) / 2) + arcRadius;
        this.activeObj.activePoint.endX = ((originalWidth - width) / 2 + width) - arcRadius;
        this.activeObj.activePoint.endY = ((originalHeight - height) / 2 + height) - arcRadius;
        if (this.factor !== 1) {
            this.activeObj.activePoint.startX += this.pannStart.startX;
            this.activeObj.activePoint.startY += this.pannStart.startY;
            this.activeObj.activePoint.endX += this.pannStart.startX;
            this.activeObj.activePoint.endY += this.pannStart.startY;
        }
        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
    };
    ImageEditor.prototype.getScale = function (value, originalValue) {
        return value > originalValue ? originalValue / value : 1;
    };
    ImageEditor.prototype.calcRatio = function () {
        var widthRatio;
        var heightRatio;
        if (this.degree === 0 || this.degree % 180 === 0) {
            widthRatio = this.baseImg.width / parseInt(this.lowerCanvas.style.maxWidth, 10);
            heightRatio = this.baseImg.height / parseInt(this.lowerCanvas.style.maxHeight, 10);
        }
        else {
            widthRatio = this.baseImg.height / parseInt(this.lowerCanvas.style.maxWidth, 10);
            heightRatio = this.baseImg.width / parseInt(this.lowerCanvas.style.maxHeight, 10);
        }
        return { width: widthRatio, height: heightRatio };
    };
    ImageEditor.prototype.calcMaxDimension = function (width, height) {
        var canvasMaxWidth = this.element.clientWidth;
        var canvasMaxHeight = this.element.clientHeight - this.toolbarHeight;
        canvasMaxHeight = Browser.isDevice ? canvasMaxHeight - this.toolbarHeight : canvasMaxHeight;
        canvasMaxWidth -= 30;
        canvasMaxHeight -= 30;
        var widthScale = canvasMaxWidth / width;
        var heightScale = canvasMaxHeight / height;
        var cssMaxWidth = Math.min(width, canvasMaxWidth);
        var cssMaxHeight = Math.min(height, canvasMaxHeight);
        if (widthScale < 1 && widthScale < heightScale) {
            cssMaxWidth = width * widthScale;
            cssMaxHeight = height * widthScale;
        }
        else if (heightScale < 1 && heightScale < widthScale) {
            cssMaxWidth = width * heightScale;
            cssMaxHeight = height * heightScale;
        }
        return { width: cssMaxWidth, height: cssMaxHeight };
    };
    ImageEditor.prototype.setMaximumDimension = function (degree) {
        var newWidth;
        var newHeight;
        if (degree % 90 === 0 && degree % 180 !== 0) {
            newWidth = this.baseImg.height;
            newHeight = this.baseImg.width;
        }
        else if (degree % 180 === 0 || degree === 0) {
            newWidth = this.baseImg.width;
            newHeight = this.baseImg.height;
        }
        this.lowerCanvas.width = this.upperCanvas.width = newWidth;
        this.lowerCanvas.height = this.upperCanvas.height = newHeight;
        var maxDimension = this.calcMaxDimension(newWidth, newHeight);
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
    };
    ImageEditor.prototype.setCursor = function (x, y) {
        var bbox = this.upperCanvas.getBoundingClientRect();
        var ratio = this.calcRatio();
        if (this.factor === 1) {
            x = (x - bbox.left) * ratio.width;
            y = (y - bbox.top) * ratio.height;
        }
        else {
            x = (x - bbox.left) + ((this.pannStart.startX) / ratio.width * this.factor);
            y = (y - bbox.top) + ((this.pannStart.startY) / ratio.height * this.factor);
        }
        if (this.activeObj.horTopLine !== undefined) {
            if (this.togglePan) {
                this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'grab';
            }
            else {
                var actObj = extend({}, this.activeObj, {}, true);
                if (this.factor !== 1) {
                    actObj = this.setCursorForZoomState(actObj, ratio, true);
                }
                if (x >= (actObj.topLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'nw-resize';
                }
                else if (x >= (actObj.topCenterCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topCenterCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topCenterCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topCenterCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'n-resize';
                }
                else if (x >= (actObj.topRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'ne-resize';
                }
                else if (x >= (actObj.centerLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.centerLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.centerLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.centerLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'w-resize';
                }
                else if (x >= (actObj.centerRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.centerRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.centerRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.centerRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'e-resize';
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'sw-resize';
                }
                else if (x >= (actObj.bottomCenterCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomCenterCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomCenterCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomCenterCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 's-resize';
                }
                else if (x >= (actObj.bottomRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'se-resize';
                }
                else if ((x >= actObj.activePoint.startX &&
                    x <= actObj.activePoint.endX) && (y >= actObj.activePoint.startY &&
                    y <= actObj.activePoint.endY)) {
                    this.upperCanvas.style.cursor = 'move';
                }
                else {
                    if (this.currObjType.isCustomCrop) {
                        this.upperCanvas.style.cursor = 'cross-hair';
                    }
                    this.upperCanvas.style.cursor = 'default';
                }
            }
        }
        else if (this.togglePan) {
            this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'grab';
        }
        else {
            if (this.currObjType.isCustomCrop || this.togglePen) {
                this.upperCanvas.style.cursor = 'crosshair';
            }
            else {
                this.upperCanvas.style.cursor = 'default';
            }
        }
        if (this.upperCanvas.style.cursor === 'default') {
            if (this.objColl.length > 0) {
                this.setCursorFromObj(x, y, this.objColl, ratio);
            }
        }
    };
    ImageEditor.prototype.setCursorFromObj = function (x, y, obj, ratio) {
        if (this.togglePan) {
            this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'grab';
        }
        else {
            for (var i = 0; i < obj.length; i++) {
                var actObj = extend({}, obj[i], {}, true);
                if (this.factor !== 1) {
                    actObj = this.setCursorForZoomState(obj[i], ratio, true);
                }
                if (x >= (actObj.topLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'nw-resize';
                    break;
                }
                else if (x >= (actObj.topCenterCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topCenterCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topCenterCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topCenterCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'n-resize';
                    break;
                }
                else if (x >= (actObj.topRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.topRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.topRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.topRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'ne-resize';
                    break;
                }
                else if (x >= (actObj.centerLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.centerLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.centerLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.centerLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'w-resize';
                    break;
                }
                else if (x >= (actObj.centerRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.centerRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.centerRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.centerRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'e-resize';
                    break;
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomLeftCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomLeftCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomLeftCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'sw-resize';
                    break;
                }
                else if (x >= (actObj.bottomCenterCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomCenterCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomCenterCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomCenterCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 's-resize';
                    break;
                }
                else if (x >= (actObj.bottomRightCircle.startX - (actObj.topLeftCircle.radius)) &&
                    x <= (actObj.bottomRightCircle.startX + (actObj.topLeftCircle.radius)) &&
                    y >= (actObj.bottomRightCircle.startY - (actObj.topLeftCircle.radius)) &&
                    y <= (actObj.bottomRightCircle.startY + (actObj.topLeftCircle.radius))) {
                    this.upperCanvas.style.cursor = 'se-resize';
                    break;
                }
                else if ((x >= actObj.activePoint.startX &&
                    x <= actObj.activePoint.endX) && (y >= actObj.activePoint.startY &&
                    y <= actObj.activePoint.endY)) {
                    this.upperCanvas.style.cursor = 'move';
                    break;
                }
                else {
                    if (this.currObjType.isCustomCrop) {
                        this.upperCanvas.style.cursor = 'cross-hair';
                    }
                    this.upperCanvas.style.cursor = 'default';
                }
            }
        }
    };
    ImageEditor.prototype.setCursorForZoomState = function (obj, ratio, isMouseMove) {
        var tempObj = extend({}, obj, {}, true);
        tempObj.activePoint.startX = (tempObj.activePoint.startX / ratio.width) * this.factor;
        tempObj.activePoint.startY = (tempObj.activePoint.startY / ratio.width) * this.factor;
        tempObj.activePoint.endX = (tempObj.activePoint.endX / ratio.width) * this.factor;
        tempObj.activePoint.endY = (tempObj.activePoint.endY / ratio.width) * this.factor;
        tempObj.activePoint.width = tempObj.activePoint.endX - tempObj.activePoint.startX;
        tempObj.activePoint.height = tempObj.activePoint.endY - tempObj.activePoint.startY;
        this.updateActiveObject(ratio, tempObj.activePoint, tempObj, isMouseMove);
        tempObj.topLeftCircle.radius = (tempObj.topLeftCircle.radius / ratio.width) * this.factor;
        return tempObj;
    };
    ImageEditor.prototype.downloadImg = function (blob, fileName) {
        var a = document.createElement('a');
        a.href = blob;
        a.target = '_parent';
        a.download = fileName;
        (document.body || document.documentElement).appendChild(a);
        a.click();
        a.parentNode.removeChild(a);
    };
    ImageEditor.prototype.toSVGImg = function (fileName) {
        var dataUrl = this.lowerCanvas.toDataURL();
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', this.lowerCanvas.style.maxWidth);
        svg.setAttribute('height', this.lowerCanvas.style.maxHeight);
        var XLinkNS = 'http://www.w3.org/1999/xlink';
        var img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        img.setAttributeNS(null, 'height', this.lowerCanvas.height.toString());
        img.setAttributeNS(null, 'width', this.lowerCanvas.width.toString());
        img.setAttributeNS(XLinkNS, 'xlink:href', dataUrl);
        svg.appendChild(img);
        var prefix = 'data:image/svg+xml;base64,';
        var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"'
            + (" width=\"" + this.lowerCanvas.width + "\"") + (" height=\"" + this.lowerCanvas.height + "\"") + '>';
        var footer = '</svg>';
        var body = svg.innerHTML;
        var data = header + body + footer;
        var svgDataUrl = prefix + btoa(data);
        if (fileName === null) {
            return svgDataUrl;
        }
        else {
            this.downloadImg(svgDataUrl, fileName + '.' + 'svg');
            return null;
        }
    };
    ImageEditor.prototype.toBlobFn = function (fileName, type) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        // eslint-disable-next-line @typescript-eslint/tslint/config
        this.lowerCanvas.toBlob(function (blob) {
            var blobUrl = URL.createObjectURL(blob);
            proxy.baseImg.src = blobUrl;
            proxy.downloadImg(blobUrl, fileName + '.' + type);
        }, 'image/png');
    };
    ImageEditor.prototype.addLetter = function (letter) {
        if (this.textBox.style.display === 'none' && (this.currObjType.isText || this.activeObj.shape === 'text')) {
            if (letter === 'Backspace') {
                this.keyHistory = this.keyHistory.slice(0, -1);
            }
            else {
                this.keyHistory += letter;
            }
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.updateFontStyles();
            var width = this.upperContext.measureText(this.keyHistory + this.tempKeyHistory).width
                + this.activeObj.textSettings.fontSize * 0.5;
            var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
            this.upperContext.fillText(this.keyHistory + this.tempKeyHistory, this.activeObj.activePoint.startX, this.activeObj.activePoint.startY +
                this.activeObj.textSettings.fontSize);
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.currObjType.isText = true;
            this.setActivePoint(width, height);
        }
    };
    ImageEditor.prototype.updateFontStyles = function (isTextBox) {
        this.upperContext.strokeStyle = this.activeObj.strokeSettings.strokeColor;
        this.upperContext.fillStyle = this.activeObj.strokeSettings.strokeColor;
        var textStyle = '';
        if (this.activeObj.textSettings.bold) {
            textStyle = 'bold ';
        }
        if (this.activeObj.textSettings.italic) {
            textStyle = 'italic ';
        }
        if (this.activeObj.textSettings.bold && this.activeObj.textSettings.italic) {
            textStyle = 'italic bold ';
        }
        var fontSize = isTextBox ? parseFloat(this.textBox.style.fontSize) : this.activeObj.textSettings.fontSize;
        var fontFamily = this.textBox.style.display === 'block' ? this.textBox.style.fontFamily : this.activeObj.textSettings.fontFamily;
        this.upperContext.font = textStyle + fontSize + 'px' + ' ' + fontFamily;
    };
    ImageEditor.prototype.updateInMemoryCanvas = function (operation) {
        if (!this.disabled) {
            var imgData = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.imgDataColl.push({ operation: operation, value: imgData });
            this.inMemoryCanvas.width = imgData.width;
            this.inMemoryCanvas.height = imgData.height;
            this.inMemoryContext.putImageData(imgData, 0, 0);
        }
    };
    ImageEditor.prototype.drawBaseImg = function () {
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
        this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
        this.inMemoryCanvas.width = this.lowerCanvas.width = this.imgDataColl[0].value.width;
        this.inMemoryCanvas.height = this.lowerCanvas.height = this.imgDataColl[0].value.height;
        this.inMemoryContext.putImageData(this.imgDataColl[0].value, 0, 0);
        var maxDimension = this.calcMaxDimension(this.inMemoryCanvas.width, this.inMemoryCanvas.height);
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
        this.lowerCanvas.style.left = this.upperCanvas.style.left = (this.element.clientWidth - maxDimension.width) / 2 + 1 + 'px';
        this.lowerCanvas.style.top = this.upperCanvas.style.top = (this.element.clientHeight - this.toolbarHeight - maxDimension.height) / 2 + 1 + 'px';
        this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
    };
    ImageEditor.prototype.calcPrevRatio = function () {
        var oldWidthRatio;
        var oldHeightRatio;
        var maxDimension;
        if (this.degree === 0 || this.degree % 180 === 0) {
            maxDimension = this.calcMaxDimension(this.baseImg.height, this.baseImg.width);
            oldWidthRatio = this.baseImg.height / maxDimension.width;
            oldHeightRatio = this.baseImg.width / maxDimension.height;
        }
        else {
            maxDimension = this.calcMaxDimension(this.baseImg.width, this.baseImg.height);
            oldWidthRatio = this.baseImg.width / maxDimension.width;
            oldHeightRatio = this.baseImg.height / maxDimension.height;
        }
        return { width: oldWidthRatio, height: oldHeightRatio };
    };
    ImageEditor.prototype.textFlipDegree = function (canvasDraw, startX, startY) {
        var rows = this.activeObj.keyHistory.split('\n');
        var height = this.activeObj.textSettings.fontSize;
        var lineHeight = ((height * rows.length) - (this.activeObj.textSettings.fontSize * rows.length)) / rows.length;
        var yPoint = (this.activeObj.textSettings.fontSize * 0.85) + lineHeight;
        for (var i = 0; i < rows.length; i++) {
            var text = rows[i];
            if (i > 0) {
                if (i === 1) {
                    yPoint -= (this.activeObj.textSettings.fontSize * 0.85);
                }
                yPoint += this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.15;
            }
            canvasDraw.fillText(text, startX + this.activeObj.textSettings.fontSize * 0.15, startY +
                yPoint + (i > 0 ? this.activeObj.textSettings.fontSize * 0.25 : -this.activeObj.textSettings.fontSize * 0.35));
        }
    };
    ImageEditor.prototype.rotateText = function (canvasDraw) {
        var startX = this.activeObj.activePoint.startX;
        var startY = this.activeObj.activePoint.startY;
        var degree;
        if (this.activeObj.shapeDegree === 0) {
            degree = this.degree;
        }
        else {
            degree = this.degree - this.activeObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (degree % 360 === 0 && (this.degree !== -360 || this.currFlipState === '')) {
            startX = this.activeObj.activePoint.startX + this.activeObj.textSettings.fontSize * 0.15;
            startY = this.activeObj.activePoint.startY + (this.activeObj.activePoint.endY - this.activeObj.activePoint.startY);
            var rows = this.activeObj.keyHistory.split('\n');
            for (var i = 0; i < rows.length; i++) {
                startY = this.activeObj.activePoint.startY + (i * this.activeObj.textSettings.fontSize +
                    this.activeObj.textSettings.fontSize * 0.25);
                canvasDraw.fillText(rows[i], startX, startY);
            }
        }
        else if (degree % 90 === 0 && degree % 180 !== 0) {
            canvasDraw.translate(this.lowerCanvas.width / 2, this.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * degree);
            canvasDraw.translate(-this.lowerCanvas.height / 2, -this.lowerCanvas.width / 2);
            if (degree % 90 === 0 && degree % 270 !== 0) {
                startY = (this.lowerCanvas.width - this.activeObj.activePoint.endX) + this.activeObj.textSettings.fontSize * 0.4;
                startX = this.activeObj.activePoint.startY;
            }
            else if (degree % 270 === 0) {
                startX = this.lowerCanvas.height - this.activeObj.activePoint.endY;
                startY = this.activeObj.activePoint.startX + this.activeObj.textSettings.fontSize * 0.4;
            }
            this.textFlipDegree(canvasDraw, startX, startY);
            canvasDraw.translate(this.lowerCanvas.height / 2, this.lowerCanvas.width / 2);
            canvasDraw.rotate(Math.PI / 180 * -degree);
            canvasDraw.translate(-this.lowerCanvas.width / 2, -this.lowerCanvas.height / 2);
        }
        else {
            canvasDraw.translate(this.lowerCanvas.width / 2, this.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * degree);
            startX = this.lowerCanvas.width - this.activeObj.activePoint.endX;
            startY = (this.lowerCanvas.height - this.activeObj.activePoint.endY) + this.activeObj.textSettings.fontSize * 0.4;
            canvasDraw.translate(-this.lowerCanvas.width / 2, -this.lowerCanvas.height / 2);
            this.textFlipDegree(canvasDraw, startX, startY);
            canvasDraw.translate(this.lowerCanvas.width / 2, this.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * -degree);
            canvasDraw.translate(-this.lowerCanvas.width / 2, -this.lowerCanvas.height / 2);
        }
        if (this.degree === 360 || this.degree === -360) {
            this.degree = 0;
        }
    };
    ImageEditor.prototype.redrawSelection = function () {
        var ratio = this.calcRatio();
        this.activeObj.activePoint.startX = 0;
        this.activeObj.activePoint.startY = 0;
        this.activeObj.activePoint.endX = this.lowerCanvas.width;
        this.activeObj.activePoint.endY = this.lowerCanvas.height;
        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
        this.updateActiveObject(ratio, this.activeObj.activePoint, this.activeObj);
        this.drawObject('duplicate', this.activeObj);
    };
    ImageEditor.prototype.redrawObj = function (degree) {
        if (this.objColl.length > 0) {
            if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical') {
                this.updateCurrentActiveObjPoint(degree);
            }
            else if (degree === 90 || degree === -90) {
                this.updateCurrentActiveObjPoint(degree);
                for (var i = 0; i < this.objColl.length; i++) {
                    this.apply(this.objColl[i].shape, this.objColl[i]);
                }
            }
            else {
                this.updateCurrentActiveObjPoint('zoom');
                for (var i = 0; i < this.objColl.length; i++) {
                    this.apply(this.objColl[i].shape, this.objColl[i]);
                }
            }
        }
        else if (this.objColl.length === 0 && (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical')) {
            if (this.activeObj.horTopLine !== undefined && (this.activeObj.shape === undefined)) {
                this.redrawSelection();
            }
            else if (this.activeObj.horTopLine !== undefined && this.activeObj.shape !== undefined) {
                var splitWords = this.activeObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    this.select(splitWords[1]);
                }
            }
        }
        else if ((degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical')) {
            var splitWords = void 0;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                this.select(splitWords[1]);
            }
            else {
                this.redrawSelection();
            }
        }
    };
    ImageEditor.prototype.updateCurrentActiveObjPoint = function (degree) {
        var oldRatio = this.calcPrevRatio();
        var ratio = this.calcRatio();
        var currActObjIndex;
        for (var index = 0; index < this.objColl.length; index++) {
            if (this.activeObj.shape === this.objColl[index].shape &&
                this.activeObj.activePoint.startX === this.objColl[index].activePoint.startX &&
                this.activeObj.activePoint.startY === this.objColl[index].activePoint.startY &&
                this.activeObj.activePoint.endX === this.objColl[index].activePoint.endX &&
                this.activeObj.activePoint.endY === this.objColl[index].activePoint.endY &&
                this.activeObj.currIndex === this.objColl[index].currIndex) {
                currActObjIndex = index;
                break;
            }
        }
        if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical') {
            if (degree === 'horizontal' || degree === 'Horizontal') {
                for (var i = 0; i < this.objColl.length; i++) {
                    if (this.objColl[i].activePoint.startX <= this.lowerCanvas.width / 2) {
                        this.objColl[i].activePoint.startX = this.lowerCanvas.width / 2 + ((this.lowerCanvas.width / 2) -
                            this.objColl[i].activePoint.endX);
                        this.objColl[i].activePoint.endX = this.objColl[i].activePoint.startX + this.objColl[i].activePoint.width;
                        this.updateActiveObject(ratio, this.objColl[i].activePoint, this.objColl[i]);
                    }
                    else if (this.objColl[i].activePoint.startX >= this.lowerCanvas.width / 2) {
                        this.objColl[i].activePoint.startX = this.lowerCanvas.width - this.objColl[i].activePoint.endX;
                        this.objColl[i].activePoint.endX = this.objColl[i].activePoint.startX + this.objColl[i].activePoint.width;
                        this.updateActiveObject(ratio, this.objColl[i].activePoint, this.objColl[i]);
                    }
                }
            }
            else if (degree === 'vertical' || degree === 'Vertical') {
                for (var i = 0; i < this.objColl.length; i++) {
                    if (this.objColl[i].activePoint.startY <= this.lowerCanvas.height / 2) {
                        this.objColl[i].activePoint.startY = this.lowerCanvas.height / 2 + ((this.lowerCanvas.height / 2) -
                            this.objColl[i].activePoint.endY);
                        this.objColl[i].activePoint.endY = this.objColl[i].activePoint.startY + this.objColl[i].activePoint.height;
                        this.updateActiveObject(ratio, this.objColl[i].activePoint, this.objColl[i]);
                    }
                    else if (this.objColl[i].activePoint.startY >= this.lowerCanvas.height / 2) {
                        this.objColl[i].activePoint.startY = this.lowerCanvas.height - this.objColl[i].activePoint.endY;
                        this.objColl[i].activePoint.endY = this.objColl[i].activePoint.startY + this.objColl[i].activePoint.height;
                        this.updateActiveObject(ratio, this.objColl[i].activePoint, this.objColl[i]);
                    }
                }
            }
            if (currActObjIndex !== undefined) {
                this.activeObj = extend({}, this.objColl[currActObjIndex], {}, true);
            }
        }
        else if (degree === 90 || degree === -90) {
            for (var i = 0; i < this.objColl.length; i++) {
                this.objColl[i].activePoint.startX /= oldRatio.width;
                this.objColl[i].activePoint.startY /= oldRatio.height;
                this.objColl[i].activePoint.endX /= oldRatio.width;
                this.objColl[i].activePoint.endY /= oldRatio.height;
                this.objColl[i].activePoint.height = this.objColl[i].activePoint.endX - this.objColl[i].activePoint.startX;
                this.objColl[i].activePoint.width = this.objColl[i].activePoint.endY - this.objColl[i].activePoint.startY;
                this.objColl[i].strokeSettings.strokeWidth /= (oldRatio.width / this.factor);
                this.calcCurrPoints(degree, this.objColl[i]);
                this.objColl[i].activePoint.endX = this.objColl[i].activePoint.startX + this.objColl[i].activePoint.width;
                this.objColl[i].activePoint.endY = this.objColl[i].activePoint.startY + this.objColl[i].activePoint.height;
                this.objColl[i].activePoint.width = this.objColl[i].activePoint.endX - this.objColl[i].activePoint.startX;
                this.objColl[i].activePoint.height = this.objColl[i].activePoint.endY - this.objColl[i].activePoint.startY;
            }
            for (var i = 0; i < this.objColl.length; i++) {
                this.objColl[i].activePoint.startX *= oldRatio.width;
                this.objColl[i].activePoint.startY *= oldRatio.height;
                this.objColl[i].activePoint.endX *= oldRatio.width;
                this.objColl[i].activePoint.endY *= oldRatio.height;
                this.objColl[i].activePoint.width = this.objColl[i].activePoint.endX - this.objColl[i].activePoint.startX;
                this.objColl[i].activePoint.height = this.objColl[i].activePoint.endY - this.objColl[i].activePoint.startY;
                this.objColl[i].strokeSettings.strokeWidth *= ratio.width;
            }
            for (var i = 0; i < this.objColl.length; i++) {
                this.updateActiveObject(ratio, this.objColl[i].activePoint, this.objColl[i]);
            }
        }
        else if (degree === 'zoom') {
            for (var i = 0; i < this.objColl.length; i++) {
                this.objColl[i].activePoint.startX /= ratio.width;
                this.objColl[i].activePoint.startY /= ratio.height;
                this.objColl[i].activePoint.endX /= ratio.width;
                this.objColl[i].activePoint.endY /= ratio.height;
                this.objColl[i].activePoint.height = this.objColl[i].activePoint.endX - this.objColl[i].activePoint.startX;
                this.objColl[i].activePoint.width = this.objColl[i].activePoint.endY - this.objColl[i].activePoint.startY;
                this.objColl[i].activePoint.startX *= ratio.width;
                this.objColl[i].activePoint.startY *= ratio.height;
                this.objColl[i].activePoint.endX *= ratio.width;
                this.objColl[i].activePoint.endY *= ratio.height;
                this.objColl[i].activePoint.width = this.objColl[i].activePoint.endX - this.objColl[i].activePoint.startX;
                this.objColl[i].activePoint.height = this.objColl[i].activePoint.endY - this.objColl[i].activePoint.startY;
            }
        }
    };
    ImageEditor.prototype.calcCurrPoints = function (degree, obj) {
        var oldRatio = this.calcPrevRatio();
        if (degree > 0) {
            var x = obj.activePoint.startX;
            obj.activePoint.startX = (this.lowerCanvas.width / oldRatio.width) - (obj.activePoint.startY + obj.activePoint.width);
            obj.activePoint.startY = x;
        }
        else {
            var y = obj.activePoint.startY;
            obj.activePoint.startY = (this.lowerCanvas.height / oldRatio.height) - (obj.activePoint.startX + obj.activePoint.height);
            obj.activePoint.startX = y;
        }
    };
    ImageEditor.prototype.redrawShape = function (obj) {
        for (var i = 0; i < this.objColl.length; i++) {
            if (JSON.stringify(obj) === JSON.stringify(this.objColl[i])) {
                this.objColl.splice(i, 1);
                break;
            }
        }
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.drawObject('duplicate', obj);
    };
    ImageEditor.prototype.applyActObj = function () {
        var isActObj = false;
        if (this.activeObj.shape !== undefined && this.activeObj.shape === 'text' && this.activeObj.keyHistory === '') {
            this.refreshActiveObj();
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        }
        else {
            var splitWords = void 0;
            var isCropSelection = false;
            if (this.activeObj.shape !== undefined) {
                splitWords = this.activeObj.shape.split('-');
            }
            if (splitWords === undefined && this.currObjType.isCustomCrop) {
                isCropSelection = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (this.activeObj.activePoint.width !== 0 && this.activeObj.activePoint.height !== 0 && !isCropSelection) {
                for (var i = 0; i < this.objColl.length; i++) {
                    if (JSON.stringify(this.activeObj) === JSON.stringify(this.objColl[i])) {
                        isActObj = true;
                        break;
                    }
                }
                if (!isActObj) {
                    if (isNullOrUndefined(this.activeObj.currIndex)) {
                        this.activeObj.currIndex = 'shape_' + (this.objColl.length + 1);
                    }
                    var splitWords_2 = this.activeObj.currIndex.split('_');
                    var tempObjColl = this.objColl.splice(0, parseInt(splitWords_2[1], 10) - 1);
                    tempObjColl.push(extend({}, this.activeObj, {}, true));
                    for (var i = 0; i < this.objColl.length; i++) {
                        tempObjColl.push(this.objColl[i]);
                    }
                    this.objColl = tempObjColl;
                    tempObjColl = [];
                    this.refreshActiveObj();
                    this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                    this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
                    for (var i = 0; i < this.objColl.length; i++) {
                        this.apply(this.objColl[i].shape, this.objColl[i]);
                    }
                    this.activeObj.flippedText = false;
                    this.currObjType.shape = '';
                    this.refreshActiveObj();
                }
            }
        }
    };
    ImageEditor.prototype.apply = function (shape, obj, canvas) {
        if (!this.disabled) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var proxy_1 = this;
            if ((this.togglePen) && !this.currObjType.isCustomCrop) {
                // eslint-disable-next-line @typescript-eslint/tslint/config
                this.upperCanvas.toBlob(function (blob) {
                    showSpinner(proxy_1.element);
                    proxy_1.element.style.opacity = '0.5';
                    proxy_1.lowerContext.clearRect(0, 0, proxy_1.lowerCanvas.width, proxy_1.lowerCanvas.height);
                    proxy_1.lowerContext.drawImage(proxy_1.inMemoryCanvas, 0, 0);
                    proxy_1.baseImg.src = URL.createObjectURL(blob);
                    proxy_1.upperContext.clearRect(0, 0, proxy_1.upperCanvas.width, proxy_1.upperCanvas.height);
                    proxy_1.togglePen = false;
                    proxy_1.upperCanvas.style.cursor = 'default';
                    for (var i = 0, len = proxy_1.objColl.length; i < len; i++) {
                        proxy_1.apply(proxy_1.objColl[i].shape, proxy_1.objColl[i], 'duplicate');
                    }
                    proxy_1.togglePen = true;
                }, 'image/png');
                this.isUndoRedo = false;
                this.degree = 0;
            }
            else {
                canvas = canvas ? canvas : 'original';
                this.currObjType.shape = shape !== undefined ? shape : this.currObjType.shape;
                if (this.currObjType.shape !== '') {
                    this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                    this.drawObject(canvas, obj);
                    this.activeObj.shape = this.currObjType.shape.toLowerCase();
                    if (!shape && this.currObjType.shape !== '' && !this.currObjType.isCustomCrop) {
                        this.objColl.push(extend({}, this.activeObj, {}, true));
                    }
                    this.keyHistory = '';
                }
                this.isUndoRedo = false;
            }
        }
    };
    ImageEditor.prototype.setCenterPoints = function (text, width, height) {
        var renderWidth;
        var renderHeight;
        if (text && width && height) {
            renderWidth = width;
            renderHeight = height;
        }
        else {
            renderWidth = this.activeObj.activePoint.width;
            renderHeight = this.activeObj.activePoint.height;
        }
        if (this.factor === 1) {
            this.activeObj.activePoint.startX = (this.lowerCanvas.width / 2) - renderWidth / 2;
            this.activeObj.activePoint.startY = (this.lowerCanvas.height / 2) - renderHeight / 2;
            this.activeObj.activePoint.endX = (this.lowerCanvas.width / 2) + renderWidth / 2;
            this.activeObj.activePoint.endY = (this.lowerCanvas.height / 2) + renderHeight / 2;
        }
        else {
            var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
            var visibleWidth = endPoint.x - this.pannStart.startX;
            var visibleHeight = endPoint.y - this.pannStart.startY;
            var centerX = (this.dragPoint.startX = visibleWidth / 2) + this.pannStart.startX;
            var centerY = this.dragPoint.startY = visibleHeight / 2 + this.pannStart.startY;
            this.activeObj.activePoint.startX = centerX - (renderWidth / 2);
            this.activeObj.activePoint.startY = centerY - (renderHeight / 2);
            this.activeObj.activePoint.endX = centerX + (renderWidth / 2);
            this.activeObj.activePoint.endY = centerY + (renderHeight / 2);
        }
        if (text && width && height) {
            this.textStartPoints.x = this.activeObj.activePoint.startX;
            this.textStartPoints.y = this.activeObj.activePoint.startY;
        }
    };
    ImageEditor.prototype.drawShape = function (type, strokeWidth, strokeColor, fillColor, start, width, height) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            var ratio = this.calcRatio();
            this.redrawActObj();
            this.togglePen = false;
            this.keyHistory = '';
            this.upperCanvas.style.display = 'block';
            this.refreshActiveObj();
            this.currObjType.shape = type;
            if (this.currObjType.shape.toLowerCase() !== 'freehanddraw' && this.currObjType.shape.toLowerCase() !== '') {
                this.activeObj.shape = this.currObjType.shape.toLowerCase();
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                if (isNullOrUndefined(this.activeObj.strokeSettings)) {
                    this.activeObj.strokeSettings = this.strokeSettings;
                }
                this.activeObj.strokeSettings.strokeWidth = strokeWidth ? strokeWidth : this.activeObj.strokeSettings.strokeWidth;
                this.activeObj.strokeSettings.strokeColor = strokeColor ? strokeColor : this.activeObj.strokeSettings.strokeColor;
                this.activeObj.strokeSettings.fillColor = fillColor ? fillColor : this.activeObj.strokeSettings.fillColor;
                var tempWidth = 100 / this.factor;
                var tempHeight = 100 / this.factor;
                this.activeObj.activePoint.width = tempWidth * ratio.width;
                this.activeObj.activePoint.height = tempHeight * ratio.height;
                if (this.currObjType.shape.toLowerCase() === 'line') {
                    this.activeObj.lineDraw = 'horizontal';
                    this.activeObj.activePoint.height /= 2;
                }
                else if (this.currObjType.shape.toLowerCase() === 'rectangle') {
                    this.activeObj.activePoint.width += this.activeObj.activePoint.width / 2;
                }
                if (this.currObjType.shape.toLowerCase() === 'ellipse' && width) {
                    this.activeObj.activePoint.width = 2 * width;
                    this.activeObj.activePoint.height = 2 * height;
                }
                if (width && height) {
                    this.activeObj.activePoint.width = width;
                    this.activeObj.activePoint.height = height;
                }
                if (start !== undefined) {
                    this.activeObj.activePoint.startX = start.x;
                    this.activeObj.activePoint.startY = start.y;
                    this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + this.activeObj.activePoint.width;
                    this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + this.activeObj.activePoint.height;
                }
                else {
                    this.setCenterPoints();
                }
                this.currObjType.isDragging = this.currObjType.isCustomCrop = false;
                this.activeObj.shapeDegree = this.degree;
                this.activeObj.flipObjColl = [];
                this.drawObject('duplicate');
                this.refreshToolbar('shapes');
            }
        }
    };
    ImageEditor.prototype.drawShapeText = function (text, fontFamily, fontSize, bold, italic, strokeColor, x, y) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            if (this.currObjType.shape === 'freehanddraw') {
                this.apply();
                this.upperCanvas.style.cursor = 'default';
                this.currObjType.shape = '';
            }
            var ratio = this.calcRatio();
            this.togglePen = false;
            this.redrawActObj();
            this.keyHistory = '';
            this.refreshActiveObj();
            var shapeChangingArgs = { action: 'insert', previousShapeSettings: this.activeObj, currentShapeSettings: this.activeObj };
            this.trigger('shapeChanging', shapeChangingArgs);
            this.currObjType.isCustomCrop = false;
            this.currObjType.isText = this.currObjType.isInitialText = true;
            this.upperCanvas.style.display = 'block';
            this.currObjType.shape = this.activeObj.shape = 'text';
            if (isNullOrUndefined(this.activeObj.textSettings)) {
                this.activeObj.textSettings = this.textSettings;
            }
            if (isNullOrUndefined(this.activeObj.strokeSettings)) {
                this.activeObj.strokeSettings = this.strokeSettings;
            }
            this.activeObj.strokeSettings.strokeColor = strokeColor ? strokeColor : this.activeObj.strokeSettings.strokeColor;
            this.activeObj.textSettings.text = text ? text : this.activeObj.textSettings.text;
            this.activeObj.textSettings.fontFamily = fontFamily ? fontFamily : this.activeObj.textSettings.fontFamily;
            this.activeObj.textSettings.text = text ? text : this.activeObj.textSettings.text;
            this.activeObj.textSettings.fontFamily = fontFamily ? fontFamily : this.activeObj.textSettings.fontFamily;
            this.activeObj.textSettings.fontSize = fontSize ? fontSize : this.activeObj.textSettings.fontSize;
            this.activeObj.textSettings.bold = bold ? bold : this.activeObj.textSettings.bold;
            this.activeObj.textSettings.italic = italic ? italic : this.activeObj.textSettings.italic;
            if (isNullOrUndefined(this.activeObj.textSettings.fontSize)) {
                if (this.lowerCanvas.width > this.lowerCanvas.height) {
                    this.activeObj.textSettings.fontSize = Math.floor((this.lowerCanvas.width / 20));
                }
                else {
                    this.activeObj.textSettings.fontSize = Math.floor((this.lowerCanvas.height / 20));
                }
                if (this.activeObj.textSettings.fontSize < 20 * (ratio.width + ratio.height)) {
                    this.activeObj.textSettings.fontSize = 20 * (ratio.width + ratio.height);
                }
            }
            this.activeObj.shapeDegree = this.degree;
            this.activeObj.shapeFlip = this.currFlipState;
            this.activeObj.flipObjColl = [];
            this.updateFontStyles();
            var width = this.upperContext.measureText(this.activeObj.textSettings.text).width +
                this.activeObj.textSettings.fontSize * 0.5;
            var height = this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25;
            if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
                this.activeObj.activePoint.startX = x;
                this.activeObj.activePoint.startY = y;
                this.activeObj.activePoint.endX = this.activeObj.activePoint.startX + width;
                this.activeObj.activePoint.endY = this.activeObj.activePoint.startY + height;
            }
            else {
                this.setCenterPoints(true, width, height);
            }
            this.addLetter(this.activeObj.textSettings.text);
            this.refreshToolbar('text');
        }
    };
    ImageEditor.prototype.drawPen = function (context) {
        var ratio = this.calcRatio();
        context = context ? context : this.upperContext;
        this.upperCanvas.style.display = 'block';
        this.canvasRatio = this.calcRatio();
        if (isNullOrUndefined(this.activeObj.strokeSettings)) {
            this.activeObj.strokeSettings = this.strokeSettings;
        }
        if (isNullOrUndefined(this.activeObj.strokeSettings.strokeWidth)) {
            this.activeObj.strokeSettings.strokeWidth = (ratio.width + ratio.height) * 0.4;
        }
        context.strokeStyle = this.activeObj.strokeSettings.strokeColor;
        context.lineWidth = 2 * (this.activeObj.strokeSettings.strokeWidth) / this.factor;
        context.beginPath();
        context.moveTo(this.prevX, this.prevY);
        context.lineTo(this.currX, this.currY);
        context.stroke();
        context.closePath();
    };
    ImageEditor.prototype.getObjDetails = function (obj) {
        var shapeDetails = {};
        shapeDetails.id = obj.currIndex;
        shapeDetails.type = obj.shape;
        shapeDetails.startX = obj.activePoint.startX;
        shapeDetails.startY = obj.activePoint.startY;
        if (obj.shape === 'rectangle') {
            shapeDetails.width = obj.activePoint.width;
            shapeDetails.height = obj.activePoint.height;
            shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
            shapeDetails.fillColor = obj.strokeSettings.fillColor;
            shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
        }
        else if (obj.shape === 'ellipse') {
            shapeDetails.radius = obj.activePoint.width / 2;
            shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
            shapeDetails.fillColor = obj.strokeSettings.fillColor;
            shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
        }
        else if (obj.shape === 'line') {
            shapeDetails.length = obj.activePoint.width;
            shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
            shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
        }
        else if (obj.shape === 'text') {
            shapeDetails.text = obj.keyHistory;
            shapeDetails.fontSize = obj.textSettings.fontSize;
            shapeDetails.color = obj.strokeSettings.strokeColor;
            shapeDetails.fontStyle = [];
            if (obj.textSettings.bold) {
                shapeDetails.fontStyle.push('bold');
            }
            if (obj.textSettings.italic) {
                shapeDetails.fontStyle.push('italic');
            }
        }
        return shapeDetails;
    };
    ImageEditor.prototype.isPointsInRange = function (x, y) {
        var inRange = false;
        if (this.factor === 1) {
            if (x >= 0 && y >= 0 && x <= this.lowerCanvas.width && y <= this.lowerCanvas.width) {
                inRange = true;
            }
        }
        else {
            var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
            if (x >= this.pannStart.startX && y >= this.pannStart.startY && x <= endPoint.x && y <= endPoint.y) {
                inRange = true;
            }
        }
        return inRange;
    };
    /**
     * Clear a current selection.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.clearSelection = function () {
        if (!this.disabled && this.imgDataColl.length > 0) {
            this.togglePen = false;
            this.refreshActiveObj();
            this.dragElement = '';
            this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
            this.currObjType.shape = '';
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.currObjType.isActiveObj = true;
            this.currObjType.isCustomCrop = false;
            this.upperCanvas.style.cursor = 'default';
        }
    };
    /**
     * Crops an image based on the selection.
     * The selection can be done through programmatically using the select method or through UI interactions.
     *
     * @returns {boolean}.
     */
    ImageEditor.prototype.crop = function () {
        var isCrop = false;
        var splitWords;
        var transitionArgs = { startPoint: { x: this.activeObj.activePoint.startX, y: this.activeObj.activePoint.startY }, endPoint: { x: this.activeObj.activePoint.endX, y: this.activeObj.activePoint.endY } };
        this.trigger('cropping', transitionArgs);
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (!this.disabled && this.activeObj.horTopLine !== undefined && (this.currObjType.isCustomCrop || splitWords[0] === 'crop')) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var proxy_2 = this;
            isCrop = true;
            this.upperCanvas.style.display = 'none';
            var widthRatio = void 0;
            var heightRatio = void 0;
            var imgData = void 0;
            var zoomedRotate = false;
            if (this.factor === 1) {
                imgData = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                widthRatio = this.lowerCanvas.width / parseInt(this.lowerCanvas.style.maxWidth, 10);
                heightRatio = this.lowerCanvas.height / parseInt(this.lowerCanvas.style.maxHeight, 10);
            }
            else {
                this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
                this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
                imgData = this.imgDataColl[0].value;
                widthRatio = this.lowerCanvas.width / parseInt(this.lowerCanvas.style.maxWidth, 10);
                heightRatio = this.lowerCanvas.height / parseInt(this.lowerCanvas.style.maxHeight, 10);
                if (this.degree !== 0 && this.flipState !== '') {
                    this.degree = 0;
                }
                if (this.degree !== 0) {
                    zoomedRotate = true;
                    this.lowerCanvas.width = this.upperCanvas.width = this.baseImg.width;
                    this.lowerCanvas.height = this.upperCanvas.height = this.baseImg.height;
                    var tempObj = extend({}, this.activeObj, {}, true);
                    this.factor = 1;
                    this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
                    this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
                    if (this.degree === 180) {
                        this.updateInMemoryContext(imgData);
                    }
                    var maxDimension = this.calcMaxDimension(tempObj.activePoint.width, tempObj.activePoint.height);
                    this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
                    this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
                    this.lowerCanvas.width = this.upperCanvas.width = maxDimension.width * widthRatio;
                    this.lowerCanvas.height = this.upperCanvas.height = maxDimension.height * heightRatio;
                    if (this.degree !== 180) {
                        this.updateInMemoryContext(imgData);
                    }
                    this.degree = 0;
                    this.lowerContext.drawImage(this.inMemoryCanvas, tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                }
                if (this.flipState !== '') {
                    zoomedRotate = true;
                    var tempObj = extend({}, this.activeObj, {}, true);
                    this.flipState = '';
                    this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
                    this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
                    this.updateInMemoryContext(imgData);
                    var maxDimension = this.calcMaxDimension(tempObj.activePoint.width, tempObj.activePoint.height);
                    this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
                    this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
                    this.lowerCanvas.width = this.upperCanvas.width = maxDimension.width * widthRatio;
                    this.lowerCanvas.height = this.upperCanvas.height = maxDimension.height * heightRatio;
                    this.lowerContext.drawImage(this.inMemoryCanvas, tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                }
            }
            if (!zoomedRotate) {
                this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
                this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.inMemoryCanvas.width = imgData.width;
                this.inMemoryCanvas.height = imgData.height;
                this.inMemoryContext.putImageData(imgData, 0, 0);
                this.updateInMemoryContext(imgData);
                var maxDimension = this.calcMaxDimension(this.activeObj.activePoint.width, this.activeObj.activePoint.height);
                this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = maxDimension.width + 'px';
                this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = maxDimension.height + 'px';
                this.lowerCanvas.width = this.upperCanvas.width = maxDimension.width * widthRatio;
                this.lowerCanvas.height = this.upperCanvas.height = maxDimension.height * heightRatio;
                var cssObj = window.getComputedStyle(this.lowerCanvas);
                this.lowerCanvas.style.left = this.upperCanvas.style.left =
                    ((this.element.clientWidth - parseInt(cssObj.width, 10) - 18) / 2) + 1 + 'px';
                this.lowerCanvas.style.top = this.upperCanvas.style.top = ((this.element.clientHeight - this.toolbarHeight
                    - parseInt(cssObj.height, 10)) / 2) + 1 + 'px';
                this.lowerContext.drawImage(this.inMemoryCanvas, this.activeObj.activePoint.startX, this.activeObj.activePoint.startY, this.activeObj.activePoint.width, this.activeObj.activePoint.height, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            }
            if (this.activeObj.shape === 'crop-circle') {
                var imgData_1 = this.lowerContext.getImageData(0, 0, this.baseImg.width, this.baseImg.height);
                this.inMemoryCanvas.width = imgData_1.width;
                this.inMemoryCanvas.height = imgData_1.height;
                this.inMemoryContext.putImageData(imgData_1, 0, 0);
                this.lowerContext.save();
                this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0, this.baseImg.width, this.baseImg.height);
                this.lowerContext.globalCompositeOperation = 'destination-in';
                this.lowerContext.beginPath();
                this.lowerContext.arc(this.lowerCanvas.width / 2, this.lowerCanvas.height / 2, this.lowerCanvas.width / 2, 0, Math.PI * 2);
                this.lowerContext.closePath();
                this.lowerContext.fill();
                this.lowerContext.restore();
                this.currObjType.isActiveObj = true;
            }
            showSpinner(this.element);
            this.element.style.opacity = '0.5';
            var blobUrl_1;
            var data_1;
            // eslint-disable-next-line @typescript-eslint/tslint/config
            this.lowerCanvas.toBlob(function (blob) {
                blobUrl_1 = URL.createObjectURL(blob);
                proxy_2.isUndoRedo = false;
                proxy_2.baseImg.src = blobUrl_1;
                data_1 = proxy_2.lowerContext.getImageData(0, 0, proxy_2.lowerCanvas.width, proxy_2.lowerCanvas.height);
                proxy_2.imgDataColl = [];
                if (!proxy_2.isUndoRedo) {
                    proxy_2.updateUndoRedoColl('crop', data_1, proxy_2.objColl);
                }
                proxy_2.isUndoRedo = false;
            }, 'image/png');
            this.objColl = [];
            this.refreshActiveObj();
            this.degree = 0;
            this.flipState = '';
            this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.lowerContext.globalAlpha = 0;
            this.lowerContext.fillRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
            this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
            this.factor = 1;
        }
        return isCrop;
    };
    ImageEditor.prototype.updateInMemoryContext = function (imgData) {
        this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
        var temp = extend({}, this.activeObj, {}, true);
        for (var i = 0; i < this.objColl.length; i++) {
            this.apply(this.objColl[i].shape, this.objColl[i]);
        }
        this.activeObj = temp;
        imgData = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.inMemoryCanvas.width = imgData.width;
        this.inMemoryCanvas.height = imgData.height;
        this.inMemoryContext.putImageData(imgData, 0, 0);
    };
    /**
     * Flips an image by horizontally or vertically.
     *
     * @param {Direction } direction - Specifies the direction to flip the image.
     * @returns {void}.
     */
    ImageEditor.prototype.flip = function (direction) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            if (this.factor !== 1) {
                this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
                this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
                this.factor = 1;
                this.refreshToolbar('main');
            }
            var transitionArgs = { direction: direction };
            this.trigger('flipping', transitionArgs);
            this.lastAction = 'flip';
            this.flipMethod = true;
            var splitWords = [];
            var activeObjShape = void 0;
            if (!isNullOrUndefined(this.activeObj.activePoint)) {
                if (this.activeObj.shape !== undefined) {
                    splitWords = this.activeObj.shape.split('-');
                }
                if (this.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                    activeObjShape = this.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                }
            }
            this.redrawActObj();
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.upperContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
            this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            if (direction.toLowerCase() === 'horizontal') {
                this.lowerContext.translate(this.lowerContext.canvas.width, 0);
                this.lowerContext.scale(-1, 1);
                this.upperContext.translate(this.upperContext.canvas.width, 0);
                this.upperContext.scale(-1, 1);
                this.flipDirection = 'horizontal';
                if (this.flipState === '' || this.flipState.toLowerCase() === 'vertical') {
                    this.flipState = 'horizontal';
                }
                if (this.currFlipState.toLowerCase() === 'horizontal') {
                    this.currFlipState = '';
                }
                else {
                    this.currFlipState = 'horizontal';
                }
            }
            else {
                this.lowerContext.translate(0, this.lowerContext.canvas.height);
                this.lowerContext.scale(1, -1);
                this.upperContext.translate(0, this.upperContext.canvas.height);
                this.upperContext.scale(1, -1);
                this.flipDirection = 'vertical';
                if (this.flipState.toLowerCase() === '' || this.flipState.toLowerCase() === 'horizontal') {
                    this.flipState = 'vertical';
                }
                if (this.currFlipState.toLowerCase() === 'vertical') {
                    this.currFlipState = '';
                }
                else {
                    this.currFlipState = 'vertical';
                }
            }
            this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
            this.currImgData = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.inMemoryCanvas.width = this.currImgData.width;
            this.inMemoryCanvas.height = this.currImgData.height;
            this.inMemoryContext.putImageData(this.currImgData, 0, 0);
            if (this.flipState.toLowerCase() === 'horizontal') {
                for (var i = 0, len = this.objColl.length; i < len; i++) {
                    this.objColl[i].flippedText = false;
                    if (this.objColl[i].shapeFlip !== '' && this.objColl[i].shapeFlip === this.currFlipState) {
                        this.apply(this.objColl[i].shape, this.objColl[i]);
                    }
                    else {
                        this.apply(this.objColl[i].shape, this.objColl[i]);
                    }
                }
                this.lowerContext.translate(this.lowerContext.canvas.width, 0);
                this.lowerContext.scale(-1, 1);
                this.upperContext.translate(this.upperContext.canvas.width, 0);
                this.upperContext.scale(-1, 1);
                this.flipDirection = '';
            }
            else if (this.flipState.toLowerCase() === 'vertical') {
                for (var i = 0, len = this.objColl.length; i < len; i++) {
                    this.objColl[i].flippedText = false;
                    if (this.objColl[i].shapeFlip !== '' && this.objColl[i].shapeFlip === this.currFlipState) {
                        this.apply(this.objColl[i].shape, this.objColl[i]);
                    }
                    else {
                        this.apply(this.objColl[i].shape, this.objColl[i]);
                    }
                }
                this.lowerContext.translate(0, this.lowerContext.canvas.height);
                this.lowerContext.scale(1, -1);
                this.upperContext.translate(0, this.upperContext.canvas.height);
                this.upperContext.scale(1, -1);
                this.flipDirection = '';
            }
            for (var i = 0, len = this.objColl.length; i < len; i++) {
                if (this.objColl[i].flipObjColl.length === 0) {
                    this.objColl[i].flipObjColl.push(direction);
                }
                else if (this.objColl[i].flipObjColl[this.objColl[i].flipObjColl.length - 1] === direction) {
                    this.objColl[i].flipObjColl.pop();
                }
                else {
                    this.objColl[i].flipObjColl.push(direction);
                }
            }
            this.redrawObj(direction.toLowerCase());
            if (this.flipState === '') {
                for (var i = 0, len = this.objColl.length; i < len; i++) {
                    this.apply(this.objColl[i].shape, this.objColl[i]);
                }
            }
            this.refreshActiveObj();
            if (!this.isUndoRedo) {
                this.updateUndoRedoColl('flip', direction, this.objColl);
            }
            this.isUndoRedo = this.flipMethod = false;
            if (!isNullOrUndefined(activeObjShape)) {
                if (activeObjShape === 'custom') {
                    this.activeObj.activePoint = { startX: 0, startY: 0, endX: this.lowerCanvas.width,
                        endY: this.lowerCanvas.height, width: this.lowerCanvas.width, height: this.lowerCanvas.height };
                    this.updateActiveObject(this.calcRatio(), this.activeObj.activePoint, this.activeObj);
                    this.drawObject('duplicate', this.activeObj);
                }
                else {
                    this.select(activeObjShape);
                }
            }
        }
    };
    /**
     * Return an image as ImageData.
     *
     * @returns {ImageData}.
     */
    ImageEditor.prototype.getImageData = function () {
        var data = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        return data;
    };
    /**
     *  Load/opens an image for editing within an image editor.
     *
     * @param {string | ImageData } data - Specifies url of the Image or image data.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.open = function (data) {
        if (!this.disabled) {
            showSpinner(this.element);
            this.element.style.opacity = '0.5';
            var toolbar_10 = document.querySelector('#' + this.element.id + '_currPos');
            if (toolbar_10) {
                toolbar_10.style.display = 'none';
            }
            if (this.defToolbarItems.length === 0 &&
                (isNullOrUndefined(document.getElementById(this.element.id + '_toolbar')))) {
                this.toolbarHeight = 0;
            }
            this.update();
            var type = typeof (data);
            if (type === 'string') {
                this.imageOnLoad(data);
            }
            else {
                this.lowerCanvas = document.querySelector('#' + this.element.id + '_lowerCanvas');
                this.upperCanvas = document.querySelector('#' + this.element.id + '_upperCanvas');
                this.lowerContext = this.lowerCanvas.getContext('2d');
                this.upperContext = this.upperCanvas.getContext('2d');
                this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
                this.inMemoryCanvas.width = this.baseImg.width = data.width;
                this.inMemoryCanvas.height = this.baseImg.height = data.height;
                this.inMemoryContext.putImageData(data, 0, 0);
                this.imgDataColl.push({ operation: 'open', value: data });
                this.lowerCanvas.width = this.upperCanvas.width = data.width;
                this.lowerCanvas.height = this.upperCanvas.height = data.height;
                this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.updateCanvas();
                hideSpinner(this.element);
                this.element.style.opacity = '1';
            }
        }
    };
    /**
     * Reset all the changesand revert to original image.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.reset = function () {
        if (!this.disabled) {
            this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
            this.inMemoryContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
            this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
            this.lowerContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
            this.upperContext.clearRect(0, 0, this.inMemoryCanvas.width, this.inMemoryCanvas.height);
            this.upperContext.clearRect(0, 0, this.inMemoryCanvas.height, this.inMemoryCanvas.width);
            showSpinner(this.element);
            this.element.style.opacity = '0.5';
            if (this.imgDataColl.length > 0) {
                if (this.imgDataColl[0].operation === 'freehanddraw') {
                    this.imgDataColl.splice(0, 1);
                    this.imgDataColl.splice(1, 1);
                }
                this.inMemoryCanvas.width = this.imgDataColl[0].value.width;
                this.inMemoryCanvas.height = this.imgDataColl[0].value.height;
                this.inMemoryContext.putImageData(this.imgDataColl[0].value, 0, 0);
                this.redrawImg();
            }
            this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
            this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
            this.baseImg.src = this.baseImgSrc;
            this.factor = 1;
            this.refreshToolbar('main');
            if (Browser.isDevice && document.getElementById(this.element.id + '_bottomToolbar')) {
                getComponent(document.getElementById(this.element.id + '_bottomToolbar'), 'toolbar').destroy();
            }
            this.objColl = [];
            this.imgDataColl = [];
            this.degree = 0;
            this.flipState = this.keyHistory = this.currFlipState = this.flipDirection = '';
            this.upperCanvas.style.display = 'none';
            this.upperCanvas.style.cursor = this.lowerCanvas.style.cursor = 'default';
            this.undoRedoColl = [];
            this.dragCanvas = this.dragged = this.isUndoRedo = this.activeObj.flippedText = this.flipMethod = false;
            this.currImgData = {};
            this.pannStart = { startX: 0, startY: 0, width: 0, height: 0 };
            this.pannEnd = { startX: 0, startY: 0, width: 0, height: 0 };
            this.lowerContext.lineWidth = this.upperContext.lineWidth = undefined;
            this.togglePan = this.togglePen = this.rotateMethod = false;
            this.lastX = this.lastY = 0;
            this.dragStart = { x: 0, y: 0 };
            this.touchEndPoint = {};
            this.prevX = this.currX = this.prevY = this.currY = 0;
            this.lastAction = this.tempKeyHistory = '';
            this.isBoldbtn = this.isItalicbtn = false;
            this.currentToolbar = 'main';
            this.textStartPoints = { x: 0, y: 0 };
            this.fontSizeColl = this.penDrawColl = [];
            this.textBox.value = this.textBox.textContent = '';
            this.textBox.style.display = 'none';
            this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
            this.textSettings =
                { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, bold: false, italic: false, underline: false };
            this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
            this.penStrokeWidth = undefined;
            this.tempTextSettings =
                { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, bold: false, italic: false, underline: false };
            this.refreshActiveObj();
            this.timer = undefined;
            this.isScreenOriented = false;
            this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false,
                isInitialLine: false, isCustomCrop: false, isZoomed: false };
        }
    };
    /**
     * Rotate an image to clockwise and anti-clockwise.
     *
     * @param {number} degree - Specifies a degree to rotate an image.
     * positive integer value for clockwise and negative integer value for anti-clockwise rotation.
     *
     * @returns {boolean}.
     */
    ImageEditor.prototype.rotate = function (degree) {
        var isRotate = false;
        if (!this.disabled && this.imgDataColl.length > 0 && (degree % 90 === 0)) {
            isRotate = true;
            var transitionArgs = { degree: degree };
            this.trigger('rotating', transitionArgs);
            this.rotateMethod = true;
            this.lastAction = 'rotate';
            var splitWords = [];
            var activeObjShape = void 0;
            if (!isNullOrUndefined(this.activeObj.activePoint)) {
                if (this.activeObj.shape !== undefined) {
                    splitWords = this.activeObj.shape.split('-');
                }
                if (this.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                    activeObjShape = this.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                }
            }
            this.redrawActObj();
            if (this.factor !== 1) {
                this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
                this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
                this.factor = 1;
                this.refreshToolbar('main');
            }
            this.degree += degree;
            if (this.degree === 360) {
                this.degree = 0;
            }
            this.lowerContext.save();
            this.setMaximumDimension(this.degree);
            this.lowerContext.translate(this.lowerCanvas.width / 2, this.lowerCanvas.height / 2);
            this.lowerContext.rotate(Math.PI / 180 * degree);
            this.lowerCanvas.style.left = this.upperCanvas.style.left = (this.element.clientWidth - parseInt(this.lowerCanvas.style.maxWidth, 10) - 18) / 2 + 1 + 'px';
            this.lowerCanvas.style.top = this.upperCanvas.style.top = (this.element.clientHeight - this.toolbarHeight - parseInt(this.lowerCanvas.style.maxHeight, 10)) / 2 + 1 + 'px';
            this.lowerContext.drawImage(this.inMemoryCanvas, -this.lowerCanvas.height / 2, -this.lowerCanvas.width / 2);
            this.lowerContext.rotate(Math.PI / 180 * -degree);
            this.lowerContext.translate(-this.lowerCanvas.width / 2, -this.lowerCanvas.height / 2);
            this.lowerContext.restore();
            this.currImgData = this.lowerContext.getImageData(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.inMemoryCanvas.width = this.currImgData.width;
            this.inMemoryCanvas.height = this.currImgData.height;
            this.inMemoryContext.putImageData(this.currImgData, 0, 0);
            this.redrawObj(degree);
            if (!isNullOrUndefined(activeObjShape)) {
                if (activeObjShape === 'custom') {
                    var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                    this.activeObj.activePoint = { startX: this.pannStart.startX, startY: this.pannStart.startY, endX: endPoint.x,
                        endY: endPoint.y, width: endPoint.x - this.pannStart.startX, height: endPoint.y - this.pannStart.startY };
                    this.updateActiveObject(this.calcRatio(), this.activeObj.activePoint, this.activeObj);
                    this.drawObject('duplicate', this.activeObj);
                }
                else {
                    this.select(activeObjShape);
                }
                this.refreshToolbar('main', true, true);
            }
            this.factor = 1;
            if (!this.isUndoRedo) {
                this.updateUndoRedoColl('rotate', degree, this.objColl);
            }
            this.isUndoRedo = false;
        }
        this.rotateMethod = false;
        return isRotate;
    };
    /**
     * Export an image using the specified file name and the extension.
     *
     * @param {string} type - Specifies a format of image to be saved.
     * @param {string} fileName  Specifies a file name to be saved
     *
     * @returns {void}.
     */
    ImageEditor.prototype.export = function (type, fileName) {
        var _this = this;
        if (!this.disabled && this.imgDataColl.length > 0) {
            if (this.togglePen) {
                this.currObjType.isZoomed = true;
                this.applyPenDraw();
            }
            this.applyActObj();
            if (this.factor !== 1) {
                this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
                this.upperContext.setTransform(1, 0, 0, 1, 0, 0);
                this.factor = 1;
                this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
                for (var i = 0; i < this.objColl.length; i++) {
                    this.apply(this.objColl[i].shape, this.objColl[i]);
                    this.refreshActiveObj();
                }
            }
            type = type ? type : 'Png';
            this.redrawActObj();
            var beforeSave = { cancel: false, fileName: 'ImageEditor', fileType: type };
            var saved_1 = { fileName: 'ImageEditor', fileType: type };
            this.trigger('beforeSave', beforeSave, function (observableSaveArgs) {
                if (!observableSaveArgs.cancel) {
                    fileName = observableSaveArgs.fileName ? observableSaveArgs.fileName : fileName;
                    if (type.toLowerCase() === 'svg') {
                        fileName = fileName || 'ImageEditor';
                        _this.toSVGImg(fileName);
                    }
                    else if (type.toLowerCase() === 'jpeg') {
                        fileName = fileName || 'ImageEditor';
                        _this.toBlobFn(fileName, type.toLowerCase());
                    }
                    else {
                        fileName = fileName || 'ImageEditor';
                        _this.toBlobFn(fileName, type.toLowerCase());
                    }
                    _this.trigger('saved', saved_1);
                    _this.refreshToolbar('main');
                }
            });
        }
    };
    /**
     * Perform selection in an image editor. The selection helps to crop an image.
     *
     * @param {string} type - Specifies the shape - circle / square / custom selection / pre-defined ratios.
     * @param {number} startX  Specifies the start x-coordinate point of the selection.
     * @param {number} startY  Specifies the start y-coordinate point of the selection.
     * @param {number} width - Specifies the width of the selection area.
     * @param {number} height - Specifies the height of the selection area.
     * @returns {void}.
     *   ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * var imageObj = new ImageEditor({
     *   created : () => {
     *     imageObj.select('16:9', 10, 10);
     *  }
     * });
     * imageObj.appendTo("#imageeditor");
     * </script>
     * ```
     */
    ImageEditor.prototype.select = function (type, startX, startY, width, height) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            var ratio = this.calcRatio();
            var points = void 0;
            this.redrawActObj();
            this.refreshActiveObj();
            this.keyHistory = '';
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.upperCanvas.style.display = 'block';
            var cropShape = 'crop-' + type;
            if (cropShape.toLowerCase() === 'crop-custom') {
                if (this.currObjType.shape === '') {
                    this.currObjType.isCustomCrop = true;
                    this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.5)';
                    this.upperContext.fillRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                    this.upperCanvas.style.cursor = 'crosshair';
                    if (Browser.isDevice) {
                        var arcRadius = (7.5 * (ratio.width > ratio.height ? ratio.width : ratio.height)) / this.factor;
                        var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                        this.activeObj.activePoint = { startX: this.pannStart.startX + arcRadius, startY: this.pannStart.startY + arcRadius,
                            endX: endPoint.x - arcRadius, endY: endPoint.y - arcRadius };
                        this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                        this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
                        this.updateActiveObject(this.calcRatio(), this.activeObj.activePoint, this.activeObj);
                        this.drawObject('duplicate', this.activeObj);
                        this.upperCanvas.style.cursor = 'default';
                    }
                }
                if (startX && startY) {
                    this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                    this.currObjType.shape = this.activeObj.shape = cropShape.toLowerCase();
                    this.activeObj.activePoint.startX = startX + ratio.width;
                    this.activeObj.activePoint.startY = startY + ratio.height;
                    this.activeObj.activePoint.endX = this.baseImg.width - (2 * ratio.width);
                    this.activeObj.activePoint.endY = this.baseImg.height - (2 * ratio.height);
                    this.activeObj.activePoint.width = this.activeObj.activePoint.endX - this.activeObj.activePoint.startX;
                    this.activeObj.activePoint.height = this.activeObj.activePoint.endY - this.activeObj.activePoint.startY;
                    this.drawObject('duplicate');
                }
            }
            else if (cropShape.toLowerCase() === 'crop-canvas') {
                this.upperCanvas.style.display = 'none';
                this.dragCanvas = true;
            }
            else {
                this.currObjType.isCustomCrop = false;
                this.currObjType.shape = cropShape.toLowerCase();
                if (width && height) {
                    points = { startX: startX, startY: startY, endX: startX + width, endY: startY + height,
                        width: width, height: height };
                }
                else if (width && cropShape === 'crop-circle') {
                    points = { startX: startX, startY: startY, endX: startX + width, endY: startY + width,
                        width: width, height: width };
                }
                this.activeObj.shape = cropShape.toLowerCase();
                this.drawObject('duplicate', null, null, true, points);
            }
        }
    };
    /**
     * Enable or disable a freehand drawing in an Image Editor.
     *
     * @param {boolean} value - Specifies a value whether enable or disable freehand drawing.
     *
     *  @returns {void}.
     */
    ImageEditor.prototype.freeHandDraw = function (value) {
        if (value) {
            this.togglePen = true;
            this.upperCanvas.style.cursor = 'cross-hair';
            this.drawPen();
        }
        else {
            this.upperCanvas.style.cursor = 'default';
            this.applyPenDraw();
        }
        this.refreshToolbar('pen');
    };
    /**
     * Enable or disable a panning on the Image Editor.
     *
     * @param {boolean} value - Specifies a value whether enable or disable panning.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.pan = function (value) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            if (value) {
                this.togglePan = true;
                this.redrawActObj();
                this.dragCanvas = true;
                this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'grab';
            }
            else {
                this.dragCanvas = this.togglePan = false;
                this.refreshActiveObj();
                this.lowerCanvas.style.cursor = this.upperCanvas.style.cursor = 'default';
            }
        }
    };
    /**
     * Increase / Decrease the magnification of an image.
     *
     * @param {boolean} value - Specifies a value to be zoomed on the image.
     * @returns {void}.
     */
    ImageEditor.prototype.zoom = function (value) {
        if (!this.disabled && this.imgDataColl.length > 0) {
            if ((this.factor === 1 && value < 0) || (this.factor > 8 && value > 0)) {
                return;
            }
            var splitWords = [];
            var activeObjShape = void 0;
            if (!isNullOrUndefined(this.activeObj.activePoint)) {
                if (this.activeObj.shape !== undefined) {
                    splitWords = this.activeObj.shape.split('-');
                }
                if (this.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                    activeObjShape = this.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                }
            }
            this.redrawActObj();
            this.refreshActiveObj();
            this.upperContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.upperCanvas.style.cursor = 'default';
            var zoomState = void 0;
            if (value === 3.75 || value === 1) {
                zoomState = 0.1;
            }
            else if (value === -3.75) {
                zoomState = -0.1;
            }
            else {
                zoomState = value;
            }
            if (this.degree !== 0) {
                this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
                this.inMemoryContext.clearRect(0, 0, this.lowerCanvas.height, this.lowerCanvas.width);
                this.inMemoryCanvas.width = this.currImgData.width;
                this.inMemoryCanvas.height = this.currImgData.height;
                this.inMemoryContext.putImageData(this.currImgData, 0, 0);
            }
            if (value === 0.1 || value === -0.1) {
                this.lastX = this.lowerCanvas.width / 2;
                this.lastY = this.lowerCanvas.height / 2;
            }
            if (value > 0) {
                this.zoomImg(3.75);
            }
            else {
                this.zoomImg(-3.75);
            }
            this.refreshActiveObj();
            if (!isNullOrUndefined(activeObjShape)) {
                if (activeObjShape === 'custom') {
                    var endPoint = { x: this.lowerCanvas.width - this.pannEnd.startX, y: this.lowerCanvas.height - this.pannEnd.startY };
                    this.activeObj.activePoint = { startX: this.pannStart.startX, startY: this.pannStart.startY, endX: endPoint.x,
                        endY: endPoint.y, width: endPoint.x - this.pannStart.startX, height: endPoint.y - this.pannStart.startY };
                    this.updateActiveObject(this.calcRatio(), this.activeObj.activePoint, this.activeObj);
                    this.drawObject('duplicate', this.activeObj);
                }
                else {
                    this.select(activeObjShape);
                }
                this.refreshToolbar('main', true, true);
            }
            if (!this.isUndoRedo) {
                this.updateUndoRedoColl('zoom', zoomState, this.objColl);
            }
            this.isUndoRedo = false;
            var zoomOut = document.querySelector('#' + this.element.id + '_zoomOut');
            if (!isNullOrUndefined(zoomOut) && this.factor === 1) {
                zoomOut.classList.add('e-disabled');
            }
            else if (!isNullOrUndefined(zoomOut)) {
                zoomOut.classList.remove('e-disabled');
            }
        }
    };
    /**
     * Draw ellipse on an image.
     *
     * @param {number} x - Specifies x-coordinate of ellipse.
     * @param {number} y - Specifies y-coordinate of ellipse.
     * @param {number} radiusX - the radius x point for the ellipse.
     * @param {number} radiusY - the radius y point for the ellipse.
     * @param {number} strokeWidth - the stroke width of ellipse.
     * @param {string} strokeColor - the stroke color of ellipse.
     * @param {string} fillColor - the fill color of the ellipse.
     * @returns {boolean}.
     *
     * ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * * var imageObj = new ImageEditor({
     * created: () => {
     * imageObj.drawEllipse(10, 10, 40, 60);
     * }
     * });
     * imageObj.appendTo("#imageeditor");
     * </script>
     * ```
     */
    ImageEditor.prototype.drawEllipse = function (x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor) {
        var isEllipse = false;
        var inRange = this.isPointsInRange(x, y);
        if (!this.disabled && this.imgDataColl.length > 0 && inRange) {
            isEllipse = true;
            var shapeChangingArgs = { action: 'insert', previousShapeSettings: this.activeObj, currentShapeSettings: this.activeObj };
            this.trigger('shapeChanging', shapeChangingArgs);
            if (this.currObjType.shape === 'freehanddraw') {
                this.apply();
                this.upperCanvas.style.cursor = 'default';
                this.currObjType.shape = '';
            }
            this.currObjType.isCustomCrop = false;
            var start = { x: x, y: y };
            this.drawShape('circle', strokeWidth, strokeColor, fillColor, start, radiusX, radiusY);
        }
        return isEllipse;
    };
    /**
     * Draw line on an image.
     *
     * @param {number} startX  Specifies start point x-coordinate of line.
     * @param {number} startY  Specifies start point y-coordinate of line.
     * @param {number} endX - Specifies end point x-coordinates of line.
     * @param {number} endY - Specifies end point y-coordinates of the line.
     * @param {number} strokeWidth - Specifies the stroke width of line.
     * @param {string} strokeColor - Specifies the stroke color of line.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawLine = function (startX, startY, endX, endY, strokeWidth, strokeColor) {
        var isLine = false;
        var inRange = this.isPointsInRange(startX, startY);
        if (!this.disabled && this.imgDataColl.length > 0 && inRange) {
            isLine = true;
            var shapeChangingArgs = { action: 'insert', previousShapeSettings: this.activeObj, currentShapeSettings: this.activeObj };
            this.trigger('shapeChanging', shapeChangingArgs);
            if (this.currObjType.shape === 'freehanddraw') {
                this.apply();
                this.upperCanvas.style.cursor = 'default';
                this.currObjType.shape = '';
            }
            this.currObjType.isCustomCrop = false;
            var start = { x: startX, y: startY };
            var width = endX - startX;
            var height = endY - startY;
            this.drawShape('line', strokeWidth, strokeColor, null, start, width, height);
        }
        return isLine;
    };
    /**
     * Draw a rectangle on an image.
     *
     * @param {number} x - Specifies x-coordinate of rectangle.
     * @param {number} y - Specifies y-coordinate of rectangle.
     * @param {number} width - Specifies the width of the rectangle.
     * @param {number} height - Specifies the height of the rectangle.
     * @param {number} strokeWidth - Specifies the stroke width of rectangle.
     * @param {string} strokeColor - Specifies the stroke color of rectangle.
     * @param {string} fillColor - the fill color of the rectangle.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawRectangle = function (x, y, width, height, strokeWidth, strokeColor, fillColor) {
        var isRectangle = false;
        var inRange = this.isPointsInRange(x, y);
        if (!this.disabled && this.imgDataColl.length > 0 && inRange) {
            isRectangle = true;
            var shapeChangingArgs = { action: 'insert', previousShapeSettings: this.activeObj,
                currentShapeSettings: this.activeObj };
            this.trigger('shapeChanging', shapeChangingArgs);
            if (this.currObjType.shape === 'freehanddraw') {
                this.apply();
                this.upperCanvas.style.cursor = 'default';
                this.currObjType.shape = '';
            }
            this.currObjType.isCustomCrop = false;
            var start = { x: x, y: y };
            this.drawShape('rectangle', strokeWidth, strokeColor, fillColor, start, width, height);
        }
        return isRectangle;
    };
    /**
     * Draw a text on an image.
     *
     * @param {number} x - Specifies x-coordinate of text.
     * @param {number} y - Specifies y-coordinate of text.
     * @param {string} text - Specifies the text to add on an image.
     * @param {string} fontFamily - Specifies the font family of the text.
     * @param {number} fontSize - Specifies the font size of the text.
     * @param {boolean} bold - Specifies whether the text is bold or not.
     * @param {boolean} italic - Specifies whether the text is italic or not.
     * @param {string} color - Specifies font color of the text.
     * @returns {boolean}.
     *
     * ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * var imageObj = new ImageEditor({
     * created: () => {
     *  imageObj.drawText(10, 10, 'Syncfusion', 'Arial', 12, true, true, '#000');
     * }
     * });
     * imageObj.appendTo("#imageeditor");
     *
     * </script>
     * ```
     */
    ImageEditor.prototype.drawText = function (x, y, text, fontFamily, fontSize, bold, italic, color) {
        var isText = false;
        var inRange = this.isPointsInRange(x, y);
        if (!this.disabled && this.imgDataColl.length > 0 && inRange) {
            isText = true;
            this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y);
        }
        return isText;
    };
    /**
     * Selects a shape based on the given shape id. The id can be got from the public method getShapeSettings.
     *
     * @param {string} id - Specifies the shape id to select a shape on an image.
     * @returns {boolean}.
     * ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * var imageObj = new ImageEditor({
     * created: () => {
     *  imageObj.selectShape('shape_1');
     * }
     * });
     * imageObj.appendTo("#imageeditor");
     * </script>
     * ```
     */
    ImageEditor.prototype.selectShape = function (id) {
        this.applyActObj();
        var obj;
        var isSelected;
        for (var i = 0; i < this.objColl.length; i++) {
            if (this.objColl[i].currIndex === id) {
                obj = extend({}, this.objColl[i], {}, true);
                break;
            }
        }
        if (isNullOrUndefined(obj)) {
            isSelected = false;
        }
        else {
            isSelected = true;
            this.activeObj = obj;
            this.redrawShape(this.activeObj);
            this.refreshToolbar('shapes');
            this.updateToolbarItems(this.calcRatio());
        }
        return isSelected;
    };
    /**
     * Deletes a shape based on the given shape id.The id can be got from the public method getShapeSettings.
     *
     * @param {string} id - Specifies the shape id to delete the shape on an image.
     * @returns {void}.
     * ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * var imageObj = new ImageEditor({
     * created: () => {
     *  imageObj.deleteShape('shape_1');
     * }
     * });
     * imageObj.appendTo("#imageeditor");
     * </script>
     * ```
     */
    ImageEditor.prototype.deleteShape = function (id) {
        this.applyActObj();
        for (var i = 0; i < this.objColl.length; i++) {
            if (this.objColl[i].currIndex === id) {
                this.objColl.splice(i, 1);
                break;
            }
        }
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.lowerContext.drawImage(this.inMemoryCanvas, 0, 0);
        for (var i = 0; i < this.objColl.length; i++) {
            this.apply(this.objColl[i].shape, this.objColl[i]);
            this.refreshActiveObj();
        }
        this.refreshToolbar('main');
    };
    /**
     * Get particular shapes details based on id of the shape which is drawn on an image editor.
     *
     * @param {string} id - Specifies the shape id on an image.
     * @returns {ShapeSettings}.
     * ```html
     * <div id='imageeditor'></div>
     * ```
     * ```typescript
     * <script>
     * var imageObj = new ImageEditor({
     * created: () => {
     *  imageObj.getShapeSetting('shape_1');
     * }
     * });
     * imageObj.appendTo("#imageeditor");
     * </script>
     * ```
     */
    ImageEditor.prototype.getShapeSetting = function (id) {
        this.applyActObj();
        var obj;
        for (var i = 0; i < this.objColl.length; i++) {
            if (this.objColl[i].currIndex === id) {
                obj = extend({}, this.objColl[i], {}, true);
                break;
            }
        }
        var shapeDetails = this.getObjDetails(obj);
        return shapeDetails;
    };
    /**
     * Get all the shapes details which is drawn on an image editor.
     *
     * @returns {ShapeSettings[]}.
     */
    ImageEditor.prototype.getShapeSettings = function () {
        this.applyActObj();
        var shapeDetailsColl = [];
        for (var i = 0; i < this.objColl.length; i++) {
            var shapeDetails = this.getObjDetails(this.objColl[i]);
            shapeDetailsColl.push(shapeDetails);
        }
        return shapeDetailsColl;
    };
    /**
     * To refresh the Canvas Wrapper.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.update = function () {
        var canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
        canvasWrapper.style.width = this.element.offsetWidth + 'px';
        this.lowerCanvas.width = this.upperCanvas.width = this.element.offsetWidth;
        if (Browser.isDevice) {
            canvasWrapper.style.height = this.element.offsetHeight - (2 * this.toolbarHeight) - 3 + 'px';
            this.lowerCanvas.height = this.upperCanvas.height = this.element.offsetHeight - (2 * this.toolbarHeight) - 3;
        }
        else {
            canvasWrapper.style.height = this.element.offsetHeight - this.toolbarHeight - 1 + 'px';
            this.lowerCanvas.height = this.upperCanvas.height = this.element.offsetHeight - this.toolbarHeight - 1;
        }
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
    };
    var ImageEditor_1;
    __decorate([
        Property('')
    ], ImageEditor.prototype, "cssClass", void 0);
    __decorate([
        Property(false)
    ], ImageEditor.prototype, "disabled", void 0);
    __decorate([
        Property('100%')
    ], ImageEditor.prototype, "height", void 0);
    __decorate([
        Property('Bootstrap5')
    ], ImageEditor.prototype, "theme", void 0);
    __decorate([
        Property()
    ], ImageEditor.prototype, "toolbar", void 0);
    __decorate([
        Property()
    ], ImageEditor.prototype, "toolbarTemplate", void 0);
    __decorate([
        Property('100%')
    ], ImageEditor.prototype, "width", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "beforeSave", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "created", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "destroyed", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "zooming", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "panning", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "cropping", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "rotating", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "flipping", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "shapeChanging", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "fileOpened", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "saved", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarCreated", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarUpdating", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarItemClicked", void 0);
    ImageEditor = ImageEditor_1 = __decorate([
        NotifyPropertyChanges
    ], ImageEditor);
    return ImageEditor;
}(SignatureBase));
export { ImageEditor };
